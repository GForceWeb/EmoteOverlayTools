/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/

// NAMESPACE OBJECT: ./src/animations/firework.js
var firework_namespaceObject = {};
__webpack_require__.r(firework_namespaceObject);
__webpack_require__.d(firework_namespaceObject, {
  emoteFirework: () => (emoteFirework)
});

// NAMESPACE OBJECT: ./src/animations/rain.js
var rain_namespaceObject = {};
__webpack_require__.r(rain_namespaceObject);
__webpack_require__.d(rain_namespaceObject, {
  emoteRain: () => (emoteRain)
});

// NAMESPACE OBJECT: ./src/animations/explode.js
var explode_namespaceObject = {};
__webpack_require__.r(explode_namespaceObject);
__webpack_require__.d(explode_namespaceObject, {
  emoteExplode: () => (emoteExplode)
});

// NAMESPACE OBJECT: ./src/animations/rise.js
var rise_namespaceObject = {};
__webpack_require__.r(rise_namespaceObject);
__webpack_require__.d(rise_namespaceObject, {
  emoteRise: () => (emoteRise)
});

// NAMESPACE OBJECT: ./src/animations/lurking.js
var lurking_namespaceObject = {};
__webpack_require__.r(lurking_namespaceObject);
__webpack_require__.d(lurking_namespaceObject, {
  create: () => (create)
});

// NAMESPACE OBJECT: ./src/animations/comets.js
var comets_namespaceObject = {};
__webpack_require__.r(comets_namespaceObject);
__webpack_require__.d(comets_namespaceObject, {
  emoteComets: () => (emoteComets)
});

// NAMESPACE OBJECT: ./src/animations/bounce.js
var bounce_namespaceObject = {};
__webpack_require__.r(bounce_namespaceObject);
__webpack_require__.d(bounce_namespaceObject, {
  emoteBounce: () => (emoteBounce)
});

// NAMESPACE OBJECT: ./src/animations/spiral.js
var spiral_namespaceObject = {};
__webpack_require__.r(spiral_namespaceObject);
__webpack_require__.d(spiral_namespaceObject, {
  emoteSpiral: () => (emoteSpiral)
});

// NAMESPACE OBJECT: ./src/animations/waves.js
var waves_namespaceObject = {};
__webpack_require__.r(waves_namespaceObject);
__webpack_require__.d(waves_namespaceObject, {
  emoteLeftWave: () => (emoteLeftWave),
  emoteRightWave: () => (emoteRightWave)
});

// NAMESPACE OBJECT: ./src/animations/carousel.js
var carousel_namespaceObject = {};
__webpack_require__.r(carousel_namespaceObject);
__webpack_require__.d(carousel_namespaceObject, {
  emoteCarousel: () => (emoteCarousel)
});

// NAMESPACE OBJECT: ./src/animations/volcano.js
var volcano_namespaceObject = {};
__webpack_require__.r(volcano_namespaceObject);
__webpack_require__.d(volcano_namespaceObject, {
  emoteVolcano: () => (emoteVolcano)
});

// NAMESPACE OBJECT: ./src/animations/text.js
var text_namespaceObject = {};
__webpack_require__.r(text_namespaceObject);
__webpack_require__.d(text_namespaceObject, {
  emoteText: () => (emoteText)
});

// NAMESPACE OBJECT: ./src/animations/dvd.js
var dvd_namespaceObject = {};
__webpack_require__.r(dvd_namespaceObject);
__webpack_require__.d(dvd_namespaceObject, {
  emoteDVD: () => (emoteDVD)
});

// NAMESPACE OBJECT: ./src/animations/coinflip.js
var coinflip_namespaceObject = {};
__webpack_require__.r(coinflip_namespaceObject);
__webpack_require__.d(coinflip_namespaceObject, {
  createCoins: () => (createCoins)
});

// NAMESPACE OBJECT: ./src/animations/cube.js
var cube_namespaceObject = {};
__webpack_require__.r(cube_namespaceObject);
__webpack_require__.d(cube_namespaceObject, {
  emoteCube: () => (emoteCube)
});

// NAMESPACE OBJECT: ./src/animations/hypetrain.js
var hypetrain_namespaceObject = {};
__webpack_require__.r(hypetrain_namespaceObject);
__webpack_require__.d(hypetrain_namespaceObject, {
  hypetrainfinish: () => (hypetrainfinish),
  hypetrainlevelup: () => (hypetrainlevelup),
  hypetrainprogression: () => (hypetrainprogression),
  hypetrainstart: () => (hypetrainstart)
});

// NAMESPACE OBJECT: ./src/animations/choon.js
var choon_namespaceObject = {};
__webpack_require__.r(choon_namespaceObject);
__webpack_require__.d(choon_namespaceObject, {
  createAvatarChoon: () => (createAvatarChoon)
});

// NAMESPACE OBJECT: ./src/animations/cheers.js
var cheers_namespaceObject = {};
__webpack_require__.r(cheers_namespaceObject);
__webpack_require__.d(cheers_namespaceObject, {
  create: () => (cheers_create)
});

// NAMESPACE OBJECT: ./src/animations/invaders.js
var invaders_namespaceObject = {};
__webpack_require__.r(invaders_namespaceObject);
__webpack_require__.d(invaders_namespaceObject, {
  emoteInvaders: () => (emoteInvaders)
});

// NAMESPACE OBJECT: ./src/animations/raiders.js
var raiders_namespaceObject = {};
__webpack_require__.r(raiders_namespaceObject);
__webpack_require__.d(raiders_namespaceObject, {
  createRaider: () => (createRaider),
  incomingRaid: () => (incomingRaid)
});

// NAMESPACE OBJECT: ./src/animations/fade.js
var fade_namespaceObject = {};
__webpack_require__.r(fade_namespaceObject);
__webpack_require__.d(fade_namespaceObject, {
  create: () => (fade_create)
});

// NAMESPACE OBJECT: ./src/animations/cyclone.js
var cyclone_namespaceObject = {};
__webpack_require__.r(cyclone_namespaceObject);
__webpack_require__.d(cyclone_namespaceObject, {
  emoteCyclone: () => (emoteCyclone)
});

// NAMESPACE OBJECT: ./src/animations/tetris.js
var tetris_namespaceObject = {};
__webpack_require__.r(tetris_namespaceObject);
__webpack_require__.d(tetris_namespaceObject, {
  emoteTetris: () => (emoteTetris)
});

;// CONCATENATED MODULE: ./src/config.js
const urlParams = new URLSearchParams(window.location.search);

let server = urlParams.get('server') === null ? "ws://localhost:8080/" : "ws://"+urlParams.get('server')+"/";

let maxemotes = urlParams.get('maxemotes') === null ? 200 : urlParams.get('maxemotes');
let subonly = urlParams.get('subonly') === null ? false : true;
let emoterain = urlParams.get('emoterain') === null ? false : true;
let welcome = urlParams.get('welcome') === null ? false : true;
let config_all = urlParams.get('all') === null ? false : true;
let lurk = urlParams.get('lurk') === null ? false : true;
let kappagen = urlParams.get('kappagen') === null ? false : true;
let config_debug = urlParams.get('debug') === null ? false : true;
let hypetrain = urlParams.get('hypetrain') === null ? false : true;
let cheers = urlParams.get('cheers') === null ? false : true;
let choon = urlParams.get('choon') === null ? false : true;


if(config_all){
lurk = true;
emoterain = true;
kappagen = true;
welcome = true;
}


let channelsub; //TODO: Build out the G-Force Sub Requirement
let hypetrainCache = [];
// //Checks for SB Actions
let BotChat;
let hypetimer;
let HypeTrainWrapper;
let HypeCart;

let config_warp = document.getElementById("confetti-container");


const root = document.documentElement;

function setCSSVars() {
  // Get the window width and height
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;

  let cssEmoteSizeStandard = Math.ceil(window.innerHeight / 14);
  let cssAvatarSizeStandard = Math.ceil(window.innerHeight / 5);

  // Set CSS variables based on window size
  root.style.setProperty('--emote-size-standard', cssEmoteSizeStandard + 'px');
  root.style.setProperty('--emote-size-large', cssEmoteSizeStandard * 2 + 'px');
  root.style.setProperty('--emote-size-small', cssEmoteSizeStandard / 2 + 'px');
  root.style.setProperty('--avatar-size-standard', cssAvatarSizeStandard + 'px');
  root.style.setProperty('--avatar-size-large', cssAvatarSizeStandard * 2 + 'px');
  root.style.setProperty('--avatar-size-small', cssAvatarSizeStandard / 2 + 'px');
}

// Call the function on page load and resize
window.addEventListener('load', setCSSVars);
window.addEventListener('resize', setCSSVars);


// Global variables
var globalVars = {
    channelsub,
    hypetrainCache,
    //Checks for SB Actions
    BotChat,
    hypetimer,
    HypeTrainWrapper,
    HypeCart,
    divnumber: 0,
  };



// Global constants
const globalConst = {
    defaultemotes: 50,
    maxemotes,
    ws: new WebSocket(server),
    warp: document.getElementById("confetti-container"),
    maxemotes,
    subonly,
    emoterain,
    welcome,
    all: config_all,
    lurk,
    kappagen,
    debug: config_debug,
    warp: config_warp,
    hypetrain,
    cheers,
    choon
};

if(globalConst.debug) {
  console.log(globalConst);
  console.log(globalVars);
}
  
/* harmony default export */ const config = ({
    globalVars,
    globalConst
});
;// CONCATENATED MODULE: ./src/helpers.js
// Randomizer
function helpers_Randomizer(min, max) {
    return min + Math.random() * (max - min);
}

function TopOrBottom() {
    var topOrBottom = Math.random();
    if (topOrBottom < 0.5) {
        return -200;
    } else {
        return innerHeight + 200;
    }
}

// Check if string ends with number
function countvalues(str) {
    return str.match(/\s[0-9]+/g);
}

let lastExecutionTime = 0;

function executeWithInterval(func, interval) {
    
    return function (...args) {
        const currentTime = Date.now();

        if (currentTime - lastExecutionTime >= interval) {
        // Sufficient time has passed, execute the function
        func(...args);
        lastExecutionTime = currentTime;
        } else {
        // Not enough time has passed, wait for the remaining time
        setTimeout(() => {
            func(...args);
            lastExecutionTime = Date.now();
        }, interval - (currentTime - lastExecutionTime));
        }
    };
}

async function getTwitchAvatar(user, id=false){


    let url = "https://decapi.me/twitch/avatar/" + user;
    let avatar;

    if(id){
        url += "?id=true";
    }
    
    // Usage example
    try {
        avatar =  await makeRequest(url)
        .then(function(response) {
            // Handle the response here
            console.log(response);
            return response;
        })
        .catch(function(error) {
            // Handle any errors that occurred during the request
            console.error(error);
        });
    } catch (error) {
    // Handle any errors that occurred during the request
    console.error(error);
    }

    return avatar;
}

function makeRequest(url) {
    return new Promise(function(resolve, reject) {
        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function() {
        if (xhttp.readyState === 4) {
            if (xhttp.status === 200) {
            resolve(xhttp.responseText); // Resolve the Promise with the response
            } else {
            reject('Error: ' + xhttp.status); // Reject the Promise with an error message
            }
        }
        };

        xhttp.open("GET", url, true);
        xhttp.send();
    });
}
  
  



// Get number at end of string
function getCommandValue(str, type) {

    let values = countvalues(str);

    if (values === null) {
        return null;
    }

    if (type == 'count') {

        if (values.length == 2) {
            return values[0].trim();
        } else if (values.length == 1) {
            return values[0].trim();
        } else {
            return null;
        }
    }

    if (type == 'interval') {

        if (values.length == 2) {
            return values[1].trim();
        } else {
            return null;
        }
    }
}

function helpers_delay(time) {
    return new Promise(resolve => setTimeout(resolve, time));
}


function randomSign() {
    return Math.random() < 0.5 ? -1 : 1;
}


function removeelement(div) {
    document.getElementById(div).remove();
}

/* harmony default export */ const helpers = ({
    delay: helpers_delay,
    randomSign,
    removeelement,
    getCommandValue,
    Randomizer: helpers_Randomizer,
    TopOrBottom,
    getTwitchAvatar,
    executeWithInterval,
});
;// CONCATENATED MODULE: ./src/animations/firework.js

const { globalVars: firework_globalVars, globalConst: firework_globalConst} = config;


function emoteFirework(images, count=100, interval=1) {

    let imgcount = images.length;
    let chargeCount =  Math.ceil(count / imgcount);

    //separate firework for each image
    for (let i = 0; i < imgcount; i++) {
    
        let explodeX = helpers.Randomizer(200, innerWidth - 200);
        let explodeY = helpers.Randomizer(200, innerHeight - 200);
        let travelTime = helpers.Randomizer(2, 5);

        setTimeout(() => {
            createFireworkTravel(images[i], explodeX, explodeY, travelTime);
        }, i * 50);

        for (let j = 0; j < chargeCount; j++) {
            setTimeout(() => {
                createFireworkExplode(images[i], explodeX, explodeY, travelTime);
                }, (j * interval));
        }
    }
}

function createFireworkTravel(image, explodeX, explodeY, travelTime) {
    
    var Div = document.createElement('div');
    Div.id = firework_globalVars.divnumber;
    firework_globalVars.divnumber++;

    gsap.set(Div, { className: 'firework-element', x: innerWidth/2, y: innerHeight, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    firework_globalConst.warp.appendChild(Div);

    // Run animation
    firework_travel_animation(Div, explodeX, explodeY, travelTime);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
      }, 5000);

}

function createFireworkExplode(image, explodeX, explodeY, travelTime) {
    
    var Div = document.createElement('div');
    Div.id = firework_globalVars.divnumber;
    firework_globalVars.divnumber++;

    gsap.set(Div, { className: 'firework-element', x: explodeX, y: explodeY, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')', opacity: 0});

    firework_globalConst.warp.appendChild(Div);

    // Run animation
    firework_explode_animation(Div, travelTime);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
      }, 15000);

}

// Explosion Animation
function firework_travel_animation(element, targetX, targety, duration=5) {
    gsap.to(element, { x: targetX, y: targety, ease: Sine.easeOut, duration: duration });
}
    
// Explosion Animation
function firework_explode_animation(element, delay=5) {
    //Fire off in a random direction
    var angle = Math.random()*Math.PI*2;
    let animatex = Math.cos(angle)*innerWidth*1.5;
    let animatey = Math.sin(angle)*innerHeight*1.5;

    gsap.set(element, { opacity: 1, delay: delay});
    gsap.to(element, helpers.Randomizer(5, 10), { x: animatex, y: animatey, ease: Sine.easeOut, delay: delay });
    gsap.to(element, helpers.Randomizer(5, 10), { opacity: 0, ease: Sine.easeIn, delay: delay });
}
;// CONCATENATED MODULE: ./src/animations/rain.js

const { globalVars: rain_globalVars, globalConst: rain_globalConst} = config;


function emoteRain(images, count=100, interval=50) {
    
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the images
        let imagenum = j % imgcount;
        //var createcommand = 'createEmoteRain("' + images[imagenum] + '")';
        setTimeout(() => {
            createEmoteRain(images[imagenum]);
        }, j * interval);
    }
}
    
    
function createEmoteRain(image) {

    var Div = document.createElement('div');
    Div.id = rain_globalVars.divnumber;
    rain_globalVars.divnumber++;

    gsap.set(Div, { className: 'falling-element', x: helpers.Randomizer(0, innerWidth), y: helpers.Randomizer(-500, -450), z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    rain_globalConst.warp.appendChild(Div);

    // Run animation
    falling_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
      }, 15000);
}

// Falling animation
function falling_animation(element) {
    //TweenMax.to(e, Randomizer(6, 16), {y:innerHeight+100, ease:Linear.easeNone, repeat:-1, delay:-15});
    //TweenMax.to(e, Randomizer(4, 8), {x:'+=100',rotationZ:Randomizer(0, 180), repeat:-1, yoyo:true, ease:Sine.easeInOut});
    //TweenMax.to(e,Randomizer(2, 8), {rotationX:Randomizer(0,360),rotationY:Randomizer(0,360),repeat:-1,yoyo:true,ease:Sine.easeInOut,delay:-5});

    TweenMax.to(element, helpers.Randomizer(6, 16), { y: innerHeight + 1400, ease: Linear.easeNone, repeat: 0, delay: -1 });
    TweenMax.to(element, helpers.Randomizer(4, 8), { x: '+=100', rotationZ: helpers.Randomizer(0, 180), repeat: 4, yoyo: true, ease: Sine.easeInOut });
    TweenMax.to(element, helpers.Randomizer(2, 8), { rotationX: helpers.Randomizer(0, 360), rotationY: helpers.Randomizer(0, 360), repeat: 8, yoyo: true, ease: Sine.easeInOut, delay: -5 });

}
;// CONCATENATED MODULE: ./src/animations/explode.js

const { globalVars: explode_globalVars, globalConst: explode_globalConst} = config;


function emoteExplode(images, count=100, interval=10) {
    
    let explodeX = helpers.Randomizer(200, innerWidth - 200);
    let explodeY = helpers.Randomizer(200, innerHeight - 200);

    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createEmoteExplode(images[imagenum], explodeX, explodeY);
          }, j * interval);
    }
}

function createEmoteExplode(image, explodeX, explodeY) {
    var Div = document.createElement('div');
    Div.id = explode_globalVars.divnumber;
    explode_globalVars.divnumber++;

    gsap.set(Div, { className: 'explosion-element', x: explodeX, y: explodeY, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    explode_globalConst.warp.appendChild(Div);

    // Run animation
    explosion_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
      }, 15000);
}

// Explosion Animation
function explosion_animation(element) {
    //Fire off in a random direction
    var angle = Math.random()*Math.PI*2;
    let animatex = Math.cos(angle)*innerWidth*1.5;
    let animatey = Math.sin(angle)*innerHeight*1.5;

    gsap.to(element, helpers.Randomizer(5, 10), { x: animatex, y: animatey, ease: Sine.easeOut });
}
    

;// CONCATENATED MODULE: ./src/animations/rise.js

const { globalVars: rise_globalVars, globalConst: rise_globalConst} = config;



function emoteRise(images, count=100, interval=20) {
    
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createEmoteRise(images[imagenum]);
        }, j * interval);
    }
}


function createEmoteRise(image) {
    var Div = document.createElement('div');
    Div.id = rise_globalVars.divnumber;
    rise_globalVars.divnumber++;

    gsap.set(Div, { className: 'rising-element', x: helpers.Randomizer(0, innerWidth), y: innerHeight - 75, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    rise_globalConst.warp.appendChild(Div);

    // Run animation
    rising_animation(Div);
    //Destroy element after 8 seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}




// Rising animation
function rising_animation(element) {
    //Fade In
    TweenMax.to(element, 3, { opacity: 1, width: "75px", height: "75px", ease: Linear.easeNone, repeat: 0, delay: -1 });
    //Vertical Movement
    TweenMax.to(element, helpers.Randomizer(10, 20), { y: -100, x: function() {
    return helpers.Randomizer(-250, 250) + gsap.getProperty(element, "x");
    }, ease: Linear.easeNone, repeat: 0, delay: -1 });
    //Fade Out
    TweenMax.to(element, 4, { opacity: 0, ease: Linear.easeNone, repeat: 0, delay: helpers.Randomizer(9, 11) });
}
;// CONCATENATED MODULE: ./src/animations/lurking.js

const { globalVars: lurking_globalVars, globalConst: lurking_globalConst} = config;



//globalConst.warp
//
//globalVars.divnumber

//setTimeout(() => {
//     createEmoteRain(images[imagenum]);
// }, j * interval);

function create(image, iterations=3, interval=5000) {
    for (let j = 0; j < iterations; j++) {
        let delay = j * interval; // Delay between each iteration in ms

        setTimeout(() => {
            createVisualLurk(image);
        }, delay);
    }
}


function lurking_animation_left(element) {
    TweenMax.to(element, 1, { rotationZ:'+=40', yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 0 });
    TweenMax.to(element, 1, { x:'+=200', yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 0 });
    TweenMax.to(element, 1, { rotationZ:'-=40' , yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 1.5 });
    TweenMax.to(element, 1, { x:'-=200' , yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 1.5 });
}

function lurking_animation_right(element) {
    TweenMax.to(element, 1, { rotationZ:'-=40', yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 0 });
    TweenMax.to(element, 1, { x:'-=200', yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 0 });
    TweenMax.to(element, 1, { rotationZ:'+=40' , yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 1.5 });
    TweenMax.to(element, 1, { x:'+=200' , yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 1.5 });
}

function lurking_animation_top(element) {
    TweenMax.to(element, 1, { y:'+=250', yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 0 });
    TweenMax.to(element, 1, { y:'-=250' , yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 1.5 });
}

function lurking_animation_bottom(element) {
    TweenMax.to(element, 1, { y:'-=250', yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 0 });
    TweenMax.to(element, 1, { y:'+=250' , yoyo:true,repeat: 0,  ease: Sine.easeInOut, delay: 1.5 });
}

function createVisualLurk(image) {
    
    var Div = document.createElement('div');
    Div.id = lurking_globalVars.divnumber;
    lurking_globalVars.divnumber++;
    Div.style.background = 'url(' + image + ')';
    Div.style.backgroundSize = '100% 100%';

    console.log("Creating a Lurk Element");

    //randomise side to peep from
    var random = Math.floor(Math.random() * 4) + 1;
                        
    switch (random) {
    case 1:
        // left - TweenLite.set(Div, { className: 'lurking-element', x: -600, y: helpers.Randomizer(0, innerHeight-600 ), z:0 });
        TweenLite.set(Div, { className: 'lurking-element', x: -400, y: helpers.Randomizer(0, innerHeight-400 ), z:0 });
        lurking_animation_left(Div);                        
        break;
    case 2:
        // right
        TweenLite.set(Div, { className: 'lurking-element', x: innerWidth, y: helpers.Randomizer(0, innerHeight-400 ), z:0  });
        lurking_animation_right(Div); 
    
        break;
    case 3:
        // top
        TweenLite.set(Div, { className: 'lurking-element', x: helpers.Randomizer(0, innerWidth-400), y: -400, z: 0,rotationX:180 });
        lurking_animation_top(Div); 
        break;
    default:
        // bottom
        TweenLite.set(Div, { className: 'lurking-element', x: helpers.Randomizer(0, innerWidth-400), y:innerHeight, z:0 });
        lurking_animation_bottom(Div); 
    }
    lurking_globalConst.warp.appendChild(Div);

    // Run animation
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}
;// CONCATENATED MODULE: ./src/animations/comets.js

const { globalVars: comets_globalVars, globalConst: comets_globalConst} = config;



function emoteComets(images, count=170, interval=50) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the different emote images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createEmoteComets(images[imagenum]);
        }, j * interval);
    }
}

function createEmoteComets(image) {
    var Div = document.createElement('div');
    Div.id = comets_globalVars.divnumber;
    comets_globalVars.divnumber++;

    //create at random Y height at left edge of screen
    gsap.set(Div, { className: 'comet-element', x: helpers.Randomizer(-500, innerWidth + 500), y: helpers.Randomizer(-200, -75), z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    comets_globalConst.warp.appendChild(Div);

    // Run animation
    comet_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);

}

function comet_animation(element) {
    var cometDuration =  helpers.Randomizer(4,8);
    var cometSize = helpers.Randomizer(25,100);
    var cometX = gsap.getProperty(element, "x");
    //console.log(cometX);
    if(cometX > 920){
    cometX = cometX - helpers.Randomizer(1150,1500);
    }
    else if(cometX < 920){
    cometX = cometX + helpers.Randomizer(1150,1500);
    }
    //console.log(cometX);
    gsap.to(element, {duration: cometDuration, x: cometX, ease: "sine.out" });
    gsap.to(element, {duration: cometDuration, y: helpers.Randomizer(800, 1080), ease: "power3.in" });
    gsap.to(element, {duration: cometDuration, width: cometSize, height: cometSize, ease: "sine.out" });
    gsap.to(element, {duration: 1, opacity: 0, ease: "sine.inOut", delay: cometDuration });
    gsap.to(element, {duration: 1, height: 0, ease: "power3.out", delay: cometDuration});
}
;// CONCATENATED MODULE: ./src/animations/bounce.js

const { globalVars: bounce_globalVars, globalConst: bounce_globalConst} = config;



function emoteBounce(images, count=100, interval=20) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the different emote images
        let imagenum = j % imgcount;        
        setTimeout(() => {
            createEmoteBounce(images[imagenum]);
        }, j * interval);
    }
}

function createEmoteBounce(image){
    var Div = document.createElement('div');
    Div.id = bounce_globalVars.divnumber;
    bounce_globalVars.divnumber++;

    //create at random Y height at left edge of screen
    gsap.set(Div, { className: 'bounce-element', x: helpers.Randomizer(0, innerWidth), y: helpers.Randomizer(0, 200), z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    bounce_globalConst.warp.appendChild(Div);

    // Run animation
    bounce_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function bounce_animation(element) {

    gsap.to(element, {
    x: function() {
        return helpers.Randomizer(0, 250) + gsap.getProperty(element, "x");
    },
    y: innerHeight-75,
    duration: 3,
    ease: "bounce.out",
    });
    //Move right as we bounce
    gsap.to(element, {
    x: "+=200",
    duration: 3,
    // ease: "sine.inOut",
    delay: 0,
    });
    //Do a flip
    gsap.to(element, {
    rotationZ: 360,
    duration: 2,
    delay: 1
    });
    gsap.to(element, {opacity: 0, duration: 1, ease: "sine.inOut", delay: 3});
}
;// CONCATENATED MODULE: ./src/animations/spiral.js

const { globalVars: spiral_globalVars, globalConst: spiral_globalConst} = config;



//globalConst.warp
//globalVarsdivnumber






function emoteSpiral(images, count=100, interval=75) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the different emote images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createSpiral(images[imagenum]);
        }, j * interval);
    }
}

function createSpiral(image){
    var Div = document.createElement('div');
    Div.id = spiral_globalVars.divnumber;
    spiral_globalVars.divnumber++;

    //create at random Y height at left edge of screen
    gsap.set(Div, { className: 'spiral-element', x: innerWidth/2, y: innerHeight/2, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    spiral_globalConst.warp.appendChild(Div);

    // Run animation
    spiral_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function spiral_animation(element) {
    //Travel left to right

    let spiralstartx = innerWidth/2;
    let spiralstarty = innerHeight/2;
    let spiralPath = "c -47 0 -85.1 -36.09 -85.1 -80.69 c 0 -52.43 44.84 -94.94 100.15 -94.94 c 65.08 0 117.84 50.01 117.84 111.69 c 0 72.58 -62.07 131.41 -138.63 131.41 c -90.09 0 -163.09 -69.21 -163.09 -154.59 c 0 -100.45 85.87 -181.88 191.87 -181.88 c 124.67 0 225.74 95.83 225.74 214 c 0 139 -118.9 251.73 -265.6 251.73 c -172.56 0 -312.44 -132.59 -312.44 -296.15 c 0 -192.42 164.57 -348.42 367.57 -348.42 c 238.83 0 432.44 183.52 432.44 409.9 c 0 266.34 -227.75 482.24 -508.75 482.24 c -330.53 0 -598.5 -254 -598.5 -567.3 c 0 -368.67 315.26 -667.5 704.15 -667.5 c 457.52 0 828.42 351.57 828.42 785.25";
    
    let finalPath = "M " + spiralstartx + " " + spiralstarty + " " + spiralPath;
    //finalPath = "M1533.07,785.75C1533.07,352.07,1162.17.5,704.65.5,315.76.5.5,299.33.5,668,.5,981.3,268.47,1235.3,599,1235.3c281,0,508.75-215.9,508.75-482.24,0-226.38-193.61-409.9-432.44-409.9-203,0-367.57,156-367.57,348.42,0,163.56,139.88,296.15,312.44,296.15C766.88,987.73,885.78,875,885.78,736c0-118.17-101.07-214-225.74-214-106,0-191.87,81.43-191.87,181.88,0,85.38,73,154.59,163.09,154.59,76.56,0,138.63-58.83,138.63-131.41,0-61.68-52.76-111.69-117.84-111.69-55.31,0-100.15,42.51-100.15,94.94C551.9,754.91,590,791,637,791";
    //finalPath = "M637,791C590,791 551.9,754.91 551.9,710.3100000000002C551.9,657.8800000000001 596.74,615.3700000000001 652.05,615.3700000000001C717.13,615.3700000000001 769.89,665.3800000000001 769.89,727.0600000000001C769.89,799.64 707.8199999999999,858.47 631.26,858.47C541.17,858.47 468.16999999999996,789.26 468.16999999999996,703.88C468.16999999999996,603.4300000000001 554.04,522 660.04,522C784.71,522 885.78,617.83 885.78,736C885.78,875 766.88,987.73 620.18,987.7299999999999C447.61999999999995,987.7299999999999 307.73999999999995,855.1399999999999 307.73999999999995,691.5799999999999C307.73999999999995,499.15999999999997 472.30999999999995,343.15999999999997 675.31,343.15999999999997C914.14,343.15999999999997 1107.75,526.68 1107.75,753.06C1107.75,1019.4 880,1235.3 599,1235.3C268.47,1235.3 .5,981.3 .5,668C.5,299.33 315.76,.5 704.65,.5C1162.17,.5 1533.07,352.07 1533.07,785.75";
    //console.log(finalPath);

    gsap.to(element, { 
    duration: 13,
    // ease: "slow(0.7, 0.7, false)",
    ease: "power1.in",
    delay: 0,
    motionPath: {
        alignOrigin: [0.5, 0.5],
        path: finalPath,
        
    }
    });
    gsap.to(element, {opacity: 0, duration: 2, delay: 11.5, ease: Sine.easeOut});

}
;// CONCATENATED MODULE: ./src/animations/waves.js

const { globalVars: waves_globalVars, globalConst: waves_globalConst} = config;



//globalConst.warp
//globalVarsdivnumber





function emoteRightWave(images, count=100, interval=20) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the different emote images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createRightWave(images[imagenum]);
        }, j * interval);
    }
}

function emoteLeftWave(images, count=100, interval=20) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the different emote images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createLeftWave(images[imagenum]);
        }, j * interval);
    }
}

function createRightWave(image){
    var Div = document.createElement('div');
    Div.id = waves_globalVars.divnumber;
    waves_globalVars.divnumber++;

    //create at random Y height at left edge of screen
    gsap.set(Div, { className: 'rightwave-element', x: -100, y: helpers.Randomizer(100, innerHeight - 100), z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    waves_globalConst.warp.appendChild(Div);

    // Run animation
    rightwave_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function createLeftWave(image){
    var Div = document.createElement('div');
    Div.id = waves_globalVars.divnumber;
    waves_globalVars.divnumber++;

    //create at random Y height at left edge of screen
    gsap.set(Div, { className: 'rightwave-element', x: innerWidth + 100, y: helpers.Randomizer(100, innerHeight - 100), z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    waves_globalConst.warp.appendChild(Div);

    // Run animation
    leftwave_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function rightwave_animation(element) {
    //Travel left to right
    gsap.to(element, { x: innerWidth + 100, duration: helpers.Randomizer(6, 11), ease: Sine.easeInOut});
    //sway up and down a bit
    gsap.to(element, { y: function() {
    return helpers.Randomizer(-350, 350) + gsap.getProperty(element, "y");
    }, duration: helpers.Randomizer(1, 2), ease: Sine.easeInOut, yoyo: true, repeat: -1});

}

function leftwave_animation(element) {
    //Travel right to left
    gsap.to(element, { x: -100, duration: helpers.Randomizer(6, 11), ease: Sine.easeInOut});
    //sway up and down a bit
    gsap.to(element, { y: function() {
    return helpers.Randomizer(-350, 350) + gsap.getProperty(element, "y");
    }, duration: helpers.Randomizer(1, 2), ease: Sine.easeInOut, yoyo: true, repeat: -1});

}
;// CONCATENATED MODULE: ./src/animations/carousel.js

const { globalVars: carousel_globalVars, globalConst: carousel_globalConst} = config;


function emoteCarousel(images, count=100, interval=120) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
    // split the count amounst the different emote images
    let imagenum = j % imgcount;
    setTimeout(() => {
        createCarousel(images[imagenum]);
    }, j * interval);
    }
}

function createCarousel(image){
    var Div = document.createElement('div');
    Div.id = carousel_globalVars.divnumber;
    carousel_globalVars.divnumber++;

    //create at random Y height at left edge of screen
    gsap.set(Div, { className: 'carousel-element', x: -100, y: innerHeight/2, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    carousel_globalConst.warp.appendChild(Div);

    // Run animation
    carousel_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function carousel_animation(element) {
    gsap.to(element, { x: innerWidth + 100, duration: 5, ease: Sine.easeInOut});
    gsap.to(element, { y: "+=200", duration: 2.5, ease: Sine.easeInOut, repeat: 1, yoyo: true});
    
    gsap.to(element, { x: -100, duration: 5, ease: Sine.easeInOut, delay: 5});
    gsap.to(element, { y: "-=200", duration: 2.5, ease: Sine.easeInOut, repeat: 1, yoyo: true, delay: 5});
}
;// CONCATENATED MODULE: ./src/animations/volcano.js

const { globalVars: volcano_globalVars, globalConst: volcano_globalConst} = config;


function emoteVolcano(images, count=100, interval=30) {

    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createEmoteVolcano(images[imagenum]);
        }, j * interval);
    }
}

function createEmoteVolcano(image) {

    var Div = document.createElement('div');
    Div.id = volcano_globalVars.divnumber;
    volcano_globalVars.divnumber++;

    gsap.set(Div, { className: 'volcano-element', x: innerWidth/2, y: innerHeight, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    volcano_globalConst.warp.appendChild(Div);

    // Run animation
    volcano_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);

}

// Explosion Animation
function volcano_animation(element) {

    //Set a base intensity value, then use that to derive the motion path
    let intensity = helpers.Randomizer(5, 100);

    let verticalStrengthx = 0;
    let verticalStrengthy = -200 * Math.ceil(intensity/20);
    let horizontalStrengthx = 20 * Math.ceil(intensity/5) 
    let horizontalStrengthy = -400 * Math.ceil(intensity/30);
    let finalLocationx = helpers.Randomizer(300, innerWidth/2);
    let finalLocationy = helpers.Randomizer(-50, -350);
    
    //Flip half to the other side
    let direction = helpers.Randomizer(0, 1);
    if(Math.round(direction) == 1) {
    verticalStrengthx = -(verticalStrengthx);
    horizontalStrengthx = -(horizontalStrengthx);
    finalLocationx = -(finalLocationx);
    }

    //Construct the Motion Path. Reference tool for paths: https://yqnn.github.io/svg-path-editor/
    let motionPath = "M"+ " " + innerWidth/2 + " " + innerHeight + " " + "c " + verticalStrengthx + " " + verticalStrengthy + " " + horizontalStrengthx + " " +  horizontalStrengthy + " " + finalLocationx + " " + finalLocationy;

    //console.log(motionPath);

    gsap.to(element, { 
    duration: helpers.Randomizer(4, 8),
    ease: "power2.out",
    delay: 0.5,
    motionPath: {
        path: motionPath,
        
    }
    });
    gsap.to(element, helpers.Randomizer(3, 5), { opacity: 0, ease: Sine.easeIn, delay: 4 });
}

;// CONCATENATED MODULE: ./src/lib/emotetext.js
const alnumDist = {
    'A': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'a': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'B': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    'b': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'C': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0]
    ],
    'c': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'D': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'd': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'E': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'e': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'F': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'f': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    'G': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 1, 0, 0]
    ],
    'g': [
     [1, 0, 0, 1, 1, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'H': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'h': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0]
    ],
    'I': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'i': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'J': [
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    'j': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 1, 0, 0]
    ],
    'K': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    'k': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
    ],
    'L': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'l': [
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    'M': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'm': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'N': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0]
    ],
    'n': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'O': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    'o': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0]
    ],
    'P': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    'p': [
     [1, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 1, 0, 0, 0, 0]
    ],
    'Q': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 1, 0, 0, 0, 0, 1, 0],
     [1, 1, 0, 1, 1, 1, 1, 0, 0]
    ],
    'q': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 0, 0, 0, 0]
    ],
    'R': [
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 1, 0, 0]
    ],
    'r': [
     [0, 1, 1, 1, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    'S': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    's': [
     [0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    'T': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0]
    ],
    't': [
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 1, 0, 0, 0]
    ],
    'U': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'u': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'V': [
     [0, 0, 0, 0, 1, 1, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 1, 1, 0]
    ],
    'v': [
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0]
    ],
    'W': [
     [0, 0, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 1, 0]
    ],
    'w': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 0, 0, 0]
    ],
    'X': [
     [0, 1, 1, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 1, 1, 0]
    ],
    'x': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    'Y': [
     [0, 0, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    'y': [
     [1, 0, 0, 1, 1, 1, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 1, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 0, 0]
    ],
    'Z': [
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0]
    ],
    'z': [
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '1': [
     [0, 1, 0, 0, 0, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '2': [
     [0, 1, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '3': [
     [0, 0, 1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '4': [
     [0, 0, 0, 1, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0]
    ],
    '5': [
     [0, 0, 1, 0, 0, 1, 1, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 1, 0, 1, 0],
     [0, 0, 1, 1, 1, 0, 0, 1, 0]
    ],
    '6': [
     [0, 0, 1, 1, 1, 1, 0, 0, 0],
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 0, 0, 0]
    ],
    '7': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 1, 1, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 1, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 1, 0]
    ],
    '8': [
     [0, 0, 1, 1, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 1, 1, 0, 0]
    ],
    '9': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 1, 1, 1, 1, 0, 0]
    ],
    '0': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0]
    ],
    ':': [
     [0, 0, 1, 0, 0, 1, 0, 0, 0]
    ],
    '.': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    ',': [
     [1, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '\'': [
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1]
    ],
    '-': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '_': [
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 0, 0, 0, 0]
    ],
    '+': [
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0]
    ],
    '=': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 0, 1, 0, 1, 0, 0, 0]
    ],
    '!': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ],
    '@': [
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 1, 1, 0, 0]
    ],
    '#': [
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0],
     [0, 0, 0, 1, 1, 1, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 1, 0, 0]
    ],
    '$': [
     [0, 0, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [1, 1, 1, 1, 1, 1, 1, 1, 1],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 0, 0]
    ],
    '\u00a2': [
     [0, 0, 1, 1, 1, 0, 0, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0],
     [1, 1, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 0, 0, 1, 0, 0, 0]
    ],
    '\u20ac': [
     [0, 0, 0, 1, 0, 1, 0, 0, 0],
     [0, 0, 1, 1, 1, 1, 1, 0, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 1, 0, 1, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 0, 1, 0]
    ],
    '\u00a3': [
     [0, 1, 0, 0, 1, 0, 1, 0, 0],
     [0, 1, 1, 1, 1, 1, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 1, 0, 0, 1, 0],
     [0, 1, 0, 0, 0, 0, 1, 0, 0]
    ],
    '\u00a5': [
     [0, 0, 0, 0, 1, 0, 1, 1, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 1, 1, 1, 1, 0, 0, 0, 0],
     [0, 0, 1, 0, 1, 1, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 1, 1, 0]
    ],
    '%': [
     [0, 1, 0, 0, 0, 0, 1, 1, 0],
     [0, 0, 1, 1, 0, 0, 1, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 1, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 1, 0]
    ],
    '?': [
     [0, 0, 0, 0, 0, 1, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 1, 0, 1, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 1, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 1, 1, 0, 0]
    ]
   };
;// CONCATENATED MODULE: ./src/animations/text.js

const { globalVars: text_globalVars, globalConst: text_globalConst} = config;




function emoteText (images, text='hype', interval=25){
    let imgcount = images.length;
    let count = 0;
    let length = text.length
    let character = 0;
    let thischaracter = [];
    
    //Iterate each letter in textstring
    for (var i = 0; i < text.length; i++) {
        //alert(str.charAt(i));
        character++;
        let char = text.charAt(i)
        let pattern = alnumDist[char];
        
        //Iterate over each line of the letter
        for (let j = 0; j < pattern.length; j++) {   
            let line = j + 1;
            //console.log(pattern[k]);
            
            
            //Iterate each pixel of line
            for (let k = 0; k < pattern[j].length; k++) {

                let position = k + 1;
                let show;
                if (pattern[j][k] == 1) {
                    show = "true";
                }
                else {
                    show = "false";
                }

                if(pattern[j][k] == 1) {
                    count++;
                    let imagenum = i % imgcount;
                    (function (image, length, character, line, position) {
                        setTimeout(() => {
                            createEmoteText(image, length, character, line, position);
                        }, j * interval);
                      })(images[imagenum], length, character, line,  position);
                }
            }
        }
        console.log(pattern);
    }
}

function createEmoteText(image, length, character, x, y) {
    var Div = document.createElement('div');
    Div.id = text_globalVars.divnumber;
    text_globalVars.divnumber++;

    let charwidthstart;
    let pixelsize = 30;
    let letterpadding = 20
    let letterwidth = 5 * pixelsize + letterpadding;

    //Total Width = Length of Word x pixels per letter x size of pixel
    let totalwidth = length * letterwidth;
    //console.log("innerWidth: " + innerWidth);
    //console.log("TotalWidth: " + totalwidth);
    if(totalwidth < innerWidth){
        charwidthstart = (innerWidth - totalwidth) / 2;
        //console.log("Shorter than width");
    }
    else {
        charwidthstart = 0;
        pixelsize = 20;
        letterpadding = 3;
        letterwidth = 5 * pixelsize + letterpadding;
        totalwidth = length * letterwidth
        charwidthstart = (innerWidth - totalwidth) / 2;

        if(totalwidth > innerWidth){
            charwidthstart = 50;
            pixelsize = 15;
            letterpadding = 3;
            letterwidth = 5 * pixelsize + letterpadding;
            totalwidth = length * letterwidth
            charwidthstart = (innerWidth - totalwidth) / 2;
        }
    }

    //Work out locations
    
    console.log("Start: " + charwidthstart + ", LetterWidth: " + letterwidth + ", Char: " + character );
    //let charwidthstart = (innerWidth / 11) + (letterwidth * (character - 1));
    charwidthstart = charwidthstart + (letterwidth * (character - 1));
    console.log("finalwidthstart: " + charwidthstart);
    let charheightstart = innerHeight / 10 * 6;
    
    let spacingX = x * pixelsize;
    let spacingY = y * pixelsize;

    let pixelX = charwidthstart + spacingX;
    let pixelY = charheightstart - spacingY;

    let startX = pixelX;
    let startY = pixelY;

    //Randomize offscreen start point
    let random = Math.round(helpers.Randomizer(1,4));
    switch(random) {
    case 1:
        // Left Offscreen
        startX = -200;
        break;
    case 2:
        // Right Offscreen
        startX = innerWidth + 200;
        break;
    case 3:
        // Above Screen
        startY = -200;
        break;
    case 4:
        // Below Screen
        startY = innerHeight + 200;
        break;
    default:
    }


    //create at random X/Y within screen bounds
    gsap.set(Div, { className: 'text-element', x: startX, y: startY, z: helpers.Randomizer(-200, 200), opacity: 0, width: pixelsize, height: pixelsize, backgroundImage: 'url(' + image + ')' });

    text_globalConst.warp.appendChild(Div);

    // Run animation
    text_animation(Div, pixelX, pixelY);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function text_animation(element, pixelX, pixelY) {
    

    gsap.to(element, {duration: 2, opacity: 1, delay: 0});
    gsap.to(element, {duration: helpers.Randomizer(3, 5), x: pixelX, y: pixelY, delay: 0});
    gsap.to(element, {duration: 2, opacity: 0, delay: 13});

    gsap.to(element, {duration: 0.7, rotation: 30, repeat: -1, repeatDelay: 3});
    gsap.to(element, {duration: 2.3, rotation: 0, ease:Elastic.easeOut.config(0.9,0.1), delay: 0.7, repeat: -1, repeatDelay: 3});

    //gsap.to(element, {duration: 0.5, x: ""});

}
;// CONCATENATED MODULE: ./src/animations/dvd.js

const { globalVars: dvd_globalVars, globalConst: dvd_globalConst} = config;


function emoteDVD (images, count=1, interval=50) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
    // split the count amounst the different emote images
    let imagenum = j % imgcount;
    setTimeout(() => {
        createEmoteDVD(images[imagenum]);
    }, j * interval);
    }
}

function createEmoteDVD(image) {
    var Div = document.createElement('div');
    Div.id = dvd_globalVars.divnumber;
    dvd_globalVars.divnumber++;

    //create at random X/Y within screen bounds
    gsap.set(Div, { className: 'dvd-element', x: helpers.Randomizer(0, innerWidth), y: helpers.Randomizer(0, innerHeight), z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    dvd_globalConst.warp.appendChild(Div);

    // Run animation
    dvd_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function dvd_animation(element) {
    let DVDStartX = gsap.getProperty(element, "x");
    let DVDStartY = gsap.getProperty(element, "y");
    let DVDStartDirection = helpers.Randomizer(0,360);
    let DVDFirstX = helpers.Randomizer(0, innerWidth);
    let DVDFirstY = helpers.Randomizer(0, innerWidth);

    DVDFirstX = Math.sin(DVDStartDirection) * 2000;
    DVDFirstY = Math.cos(DVDStartDirection) * 2000;

    console.log(DVDFirstX);
    console.log(DVDFirstY);
    
    gsap.to(element, {
    duration: 15,
    x: helpers.Randomizer(4000, 8000) * helpers.randomSign(), 
    y: helpers.Randomizer(4000, 8000) * helpers.randomSign(),    
    modifiers: { x: modX, y: modY }
    }); 

    gsap.to(element, {duration: 1, opacity: 0, delay: 14});

}

function modX(x) {

    var minX = 0;
    var size = 75;
    var maxX = innerWidth  - size;
    x = parseInt(x);
        
    if (x > maxX || x < minX) {
        
        var delta = ((x % maxX) + maxX) % maxX;
        var start = x > maxX ? 1 : 0;
        var ratio = x / maxX + start;
        var even  = !(ratio & 1);
    
        x = even ? maxX - delta : minX + delta;
    
    }
    
    // console.log(x);
    
    return x + 'px';
}
    
function modY(y) {
        
    var minY = 0;
    var size = 75;
    var maxY = innerHeight - size;
    y = parseInt(y);
    
    if (y > maxY || y < minY) {
        
        var delta = ((y % maxY) + maxY) % maxY;
        var start = y > maxY ? 1 : 0;
        var ratio = y / maxY + start;
        var even  = !(ratio & 1);
    
        y = even ? maxY - delta : minY + delta;
    }
    
    // console.log(y);
    
    return y + 'px';
}
;// CONCATENATED MODULE: ./src/animations/coinflip.js

const { globalVars: coinflip_globalVars, globalConst: coinflip_globalConst} = config;



//globalConst.warp
//globalVarsdivnumber

function createCoins(count, side) {

    //var template = $(".template").remove();
    let template = document.querySelector(".template");
    let coinTl = new TimelineMax();
    let jumpTime = (Math.random() * .75) + .8;
    let coins = [];
    
    for (var i = 0; i < count; i++) {
        // Copy the template
        let clone = template.cloneNode(true);
        coinflip_globalConst.warp.append(clone);
        clone.id = coinflip_globalVars.divnumber;
        coinflip_globalVars.divnumber++;


        setTimeout(() => {
            helpers.removeelement(clone.id);
        }, 60000);
        
        // Finds the images inside the clone
        let img = document.querySelector(".template").querySelectorAll('img');
        
        let coin = {
            index : i,
            box   : clone,
            heads : img[0],
            edge  : img[1],
            line  : img[2],
            tails : img[3],
            flip  : function() {
            //if(side == "heads") { var result = headFlip(this);}
            //if(side == "tails") { var result = tailFlip(this);}
            //return getFlippage(this.box, result);
            }
        };

        coins.push(coin);

        gsap.set(clone, { x: innerWidth / 2 - 100, y: innerHeight / 2 + 100, autoAlpha: 1, opacity: 0 });
        gsap.to(clone, { opacity: 1, duration: 1 });

        setTimeout(() => {
            flippage(coin, side);
        }, 4000);
    } 
    

    // setTimeout(function() {
    //     flippage(coin, side);
    // }, 4000);
    
    //return coins;  
}

function flippage(coin, side) {
    
    if(side != "Heads" && side != "Tails") {
        return
    }

    let flipTime = 1 / 3;

    let tl1 = gsap.timeline({ repeat: 0, defaults: { duration: 3, ease: "none" } })
    // tl1.addLabel("headEnd2", 0);
    // tl1.addLabel("tailStart2", ">");
    tl1.to(coin.box, {y: "-=200", rotation: 10, duration: 3, ease: Power1.easeOut});
    tl1.to(coin.box, {y: "+=200", rotation: -10, duration: 3, ease: Bounce.easeOut});
    tl1.to(coin.box, {rotation: 0, duration: 0.1  });

    if(side == "Heads"){
    //heads
    let tl2 = gsap.timeline({ repeat: 3, defaults: { duration: flipTime, ease: "none" } })
    tl2.fromTo(coin.heads, {scaleY: 1, y: 0}, {scaleY: 0, y: 0}, "headEnd");
    tl2.fromTo(coin.heads, {scaleY: 1, y: 0}, {scaleY: 0, y: 8}, "headEnd");
    tl2.fromTo(coin.line, {height: 0, y: 0}, {height: 8, y: 0}, "headEnd");
    tl2.to(coin.heads, {y: 0, duration: 0}, "tailStart");
    tl2.fromTo(coin.tails, {opacity: 1, scaleY: 0, y: 8}, {opacity: 1, scaleY: 1, y: 0}, "tailStart");
    tl2.to(coin.edge, {scaleY: 1, y: 0}, "tailStart");
    tl2.to(coin.line, {height: 0, y: 0}, "tailStart");
    tl2.to(coin.tails, {scaleY: 0 }, "tailEnd");
    tl2.fromTo(coin.edge, {scaleY: 1, y: 0}, {scaleY: 0, y: 8}, "tailEnd");
    tl2.to(coin.line, {height: 8, y: 0}, "tailEnd");
    tl2.fromTo(coin.heads, {scaleY: 0, y: 8}, {scaleY: 1, y: 0}, "headStart");
    tl2.fromTo(coin.edge, {scaleY: 0, y: 0}, {scaleY: 1, y: 0}, "headStart");
    tl2.to(coin.line, {height: 0, y: 0 }, "headStart");
    }

    if(side == "Tails"){
        
    //tails
    let tl2 = gsap.timeline({ repeat: 5, defaults: { duration: flipTime, ease: "none" } })
    tl2.fromTo(coin.heads, {scaleY: 1, y: 0}, {scaleY: 0, y: 0}, "headEnd2");
    tl2.fromTo(coin.edge, {scaleY: 1, y: 0}, {scaleY: 0, y: 8}, "headEnd2");
    tl2.fromTo(coin.line, {height: 0, y: 0}, {height: 8, y: 0}, "headEnd2");
    tl2.to(coin.edge, {y: 0, duration: 0}, "tailStart2");
    tl2.fromTo(coin.tails, {opacity: 1, scaleY: 0, y: 8}, {opacity: 1, scaleY: 1, y: 0}, "tailStart2");
    tl2.to(coin.edge, {scaleY: 1, y: 0}, "tailStart2");
    tl2.to(coin.line, {height: 0, y: 0}, "tailStart2");
    }

    

}

function getFlippage(coin, whatSide) {

    //define jumping
    jumpTime = (Math.random() * 1.75) + .8;
    var jumpTl = new TimelineMax();
    var jumpUp = new TweenMax(coin, jumpTime / 2, {
    y: -100,
    rotation: 10,
    ease: Power1.easeOut
    });
    var jumpDown = new TweenMax(coin, jumpTime / 2, {
    y: 100,
    rotation: -10,
    ease: Bounce.easeOut
    });

    jumpTl
    .add(jumpUp.play())
    .add(jumpDown.play())
    .to(coin, .1, {
    rotation: 0
    }, "-=.2");

    // timeline for each
    var coinFlipTl = new TimelineMax();
    coinFlipTl
    .add(whatSide, 0) //picks whether to land on heads or tails
    .add(jumpTl, 0);
    return coinFlipTl;
}

//makes a new animation for a coin that's tails
// function tailFlip(coin) {

//   var flipTime = 1 / 3;  
//   var tailsTl = new TimelineMax({ repeat: 1 });
    
//   tailsTl
//     .fromTo(coin.heads, flipTime, {
//     scaleY: 1,
//     y: 0
//   }, {
//     scaleY: 0,
//     y: 0
//   }, "headEnd2")
//     .fromTo(coin.edge, flipTime, {
//     scaleY: 1,
//     y: 0
//   }, {
//     scaleY: 0,
//     y: 8
//   }, "headEnd2")
//     .fromTo(coin.line, flipTime, {
//     height: 0,
//     y: 0
//   }, {
//     height: 8,
//     y: 0
//   }, "headEnd2")

//     .to(coin.edge, 0, {
//     y: 0
//   }, "tailStart2")
//     .fromTo(coin.tails, flipTime, {
//     opacity: 1,
//     scaleY: 0,
//     y: 8
//   }, {
//     opacity: 1,
//     scaleY: 1,
//     y: 0
//   }, "tailStart2")
//     .to(coin.edge, flipTime, {
//     scaleY: 1,
//     y: 0
//   }, "tailStart2")
//     .to(coin.line, flipTime, {
//     height: 0,
//     y: 0
//   }, "tailStart2");

//   return tailsTl;
// };

// function headFlip(coin) {
    
//   var flipTime = 1 / 4;
//   var headsTl = new TimelineMax({ repeat: 1 });
    
//   headsTl
//     .fromTo(coin.heads, flipTime, {
//     scaleY: 1,
//     y: 0
//   }, {
//     scaleY: 0,
//     y: 0
//   }, "headEnd")
//     .fromTo(coin.heads, flipTime, {
//     scaleY: 1,
//     y: 0
//   }, {
//     scaleY: 0,
//     y: 8
//   }, "headEnd")
//     .fromTo(coin.line, flipTime, {
//     height: 0,
//     y: 0
//   }, {
//     height: 8,
//     y: 0
//   }, "headEnd")

//     .to(coin.heads, 0, {
//     y: 0
//   }, "tailStart")
//     .fromTo(coin.tails, flipTime, {
//     opacity: 1,
//     scaleY: 0,
//     y: 8
//   }, {
//     opacity: 1,
//     scaleY: 1,
//     y: 0
//   }, "tailStart")
//     .to(coin.edge, flipTime, {
//     scaleY: 1,
//     y: 0
//   }, "tailStart")
//     .to(coin.line, flipTime, {
//     height: 0,
//     y: 0
//   }, "tailStart")

//     .to(coin.tails, flipTime, {
//     scaleY: 0
//   }, "tailEnd")
//     .fromTo(coin.edge, flipTime, {
//     scaleY: 1,
//     y: 0
//   }, {
//     scaleY: 0,
//     y: 8
//   }, "tailEnd")
//     .to(coin.line, flipTime, {
//     height: 8,
//     y: 0
//   }, "tailEnd")
//     .fromTo(coin.heads, flipTime, {
//     scaleY: 0,
//     y: 8
//   }, {
//     scaleY: 1,
//     y: 0
//   }, "headStart")
//     .fromTo(coin.edge, flipTime, {
//     scaleY: 0,
//     y: 0
//   }, {
//     scaleY: 1,
//     y: 0
//   }, "headStart")
//     .to(coin.line, flipTime, {
//     height: 0,
//     y: 0
//   }, "headStart");
    
//   return headsTl;
// };

// function buildTimeline(coins, coinTl) {

//   // forEach is an array method
//   coins.forEach(function(coin) {    
//     coinTl.add(coin.flip(), 0);
//   });
// };

;// CONCATENATED MODULE: ./src/animations/cube.js

const { globalVars: cube_globalVars, globalConst: cube_globalConst} = config;



//globalConst.warp
//globalVarsdivnumber





function emoteCube (images, count=1, interval=50) {
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the different emote images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createEmoteCube(images[imagenum]);
        }, j * interval);
    }
}

function createEmoteCube(image) {
    var Div = document.createElement('div');
    Div.id = divnumber;
    divnumber++;

    //create at random X/Y within screen bounds
    gsap.set(Div, { className: 'cube-element', x: Randomizer(0, innerWidth), y: Randomizer(0, innerHeight), z: Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    warp.appendChild(Div);

    // Run animation
    cube_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function cube_animation(element) {


}
;// CONCATENATED MODULE: ./src/animations/hypetrain.js

const { globalVars: hypetrain_globalVars, globalConst: hypetrain_globalConst} = config;




//Add user avatar to current train car
function hypetrainprogression(userId){

    var xhttp = new XMLHttpRequest();
    console.log("created xmlhttp object");
    xhttp.onreadystatechange = function () {
    if (this.readyState == 4 && this.status == 200) {
        // get display image for the userId
        console.log("got a user image response back");
        // console.log(xhttp.responseText);
        
        let image = [xhttp.responseText];
        createhypetrainprogression(image);

        }
    };

    xhttp.open("GET", "https://decapi.me/twitch/avatar/" + userId + "?id=true", true);
    xhttp.send();
}

function createhypetrainprogression(image){

    let HypeWrapper = document.getElementsByClassName('train-wrapper');
    let carts = document.getElementsByClassName('train-cart');
    let cartsArray = Array.from(carts);
    let currentCart = cartsArray[cartsArray.length - 1];

    let UserImage = document.createElement('img');

    //image = "https://static-cdn.jtvnw.net/emoticons/v2/emotesv2_2758558107d148c9b1e73c56cb2d9e06/default/dark/2.0";

    gsap.set(UserImage, { className: 'cart-image', z: 10, zIndex: 10, position: "absolute", left: "20px;", top: "70px", attr: { src: image } });

    currentCart.appendChild(UserImage);
    passenger_animation(UserImage)

}

//Fade and Clear the Hype Train
function hypetrainfinish(){

    //console.log(HypeTrainWrapper.id);
    let HypeWrapper = document.getElementsByClassName('train-wrapper')[0];

    clearTimeout(HypeWrapper.id);

    fade(HypeWrapper, 0, 4.5);

    setTimeout(() => {
        helpers.removeelement(HypeWrapper.id);
    }, 5000);

}

function hypetrainstart(){

    let image = "../assets/img/trainhead.png";
    let HypeTrainWrapper = document.createElement('div');
    HypeTrainWrapper.id = setTimeout(() => {
        helpers.removeelement(HypeTrainWrapper.id);
    }, 360000);

    let HypeTrainHead = document.createElement('div');

    gsap.set(HypeTrainWrapper, { className: 'train-wrapper', x: 0 - innerWidth, y: 0, z: helpers.Randomizer(-200, 200), opacity: 0 });
    gsap.set(HypeTrainHead, { className: 'train-head', float: "right", z: helpers.Randomizer(-200, 200), width: "225px", height: "225px", backgroundImage: 'url(' + image + ')' });

    hypetrain_globalConst.warp.appendChild(HypeTrainWrapper);
    HypeTrainWrapper.appendChild(HypeTrainHead); 

    
    // console.log("Timeout:");
    // console.log(hypetimer);

    fade(HypeTrainWrapper, 1, 3);
    train_animation(HypeTrainWrapper);
    hypetrainlevelup();

    let delayTime = 1000;
    if(hypetrain_globalVars.hypetrainCache){
        hypetrain_globalVars.hypetrainCache.forEach(async (userId) => {
            delay(delayTime).then(() => hypetrainprogression(userId));
            delayTime = delayTime + 3000;
        });
    }
}

//Add additional Car to Train
function hypetrainlevelup(){

    //reset the timeout on LevelUp
    let trainWrapper = document.getElementsByClassName('train-wrapper')[0];

    console.log(trainWrapper.id);

    //Level up resets 5 minute timer
    clearTimeout(trainWrapper.id);
    trainWrapper.id = setTimeout(() => {
        helpers.removeelement(trainWrapper.id);
    }, 365000);

    let cartNum = Math.round(helpers.Randomizer(1,2));
    let image;
    if(cartNum == 1){
        image = "../assets/img/cart1.png";
    }
    if(cartNum == 2){
        image = "../assets/img/cart2.png";
    }
    else {
        image = "../assets/img/cart1.png";
    }

    let HypeCart = document.createElement('div');
    gsap.set(HypeCart, { className: 'train-cart', float: "right", z: helpers.Randomizer(-200, 200), width: "225px", height: "225px", opacity: 0 });


    let CartImage = document.createElement('img');
    gsap.set(CartImage, { className: 'cart-image', z: 100, zIndex: 100, position: "relative", width: "225px", height: "225px", attr: { src: image }  });

    trainWrapper.appendChild(HypeCart);
    HypeCart.appendChild(CartImage);
    fade(HypeCart, 1, 3);

}


function fade(element, opacity, duration){
    gsap.to(element, {opacity: opacity, duration: duration});
}

function train_animation(element){
    gsap.timeline({ repeat: -1, defaults: { duration: 3, ease: "none" } })
    .to(element, { x: innerWidth, duration: 10 })
    .to(element, { y: -500, duration: 0.5 })
    .to(element, { x: 0 - innerWidth, duration: 0.5 })
    .to(element, { y: 0, duration: 0.5 });
}

function passenger_animation(element) {
    gsap.timeline({ repeat: -1, defaults: { duration: 3, ease: "none" } })
    .to(element, { x: "+=120" })
    .to(element, { x: "-=120" });
    gsap.to(element, {duration: 1, repeat: -1, y: "-=20", ease: "sine.out", yoyo: true });
}
;// CONCATENATED MODULE: ./src/animations/choon.js

const { globalVars: choon_globalVars, globalConst: choon_globalConst} = config;



//globalConst.warp
//globalVarsdivnumber

function createAvatarChoon(image) {
    var Div = document.createElement('div');
    Div.id = choon_globalVars.divnumber;
    choon_globalVars.divnumber++;
    Div.style.background = 'url(' + image + ')';
    Div.style.backgroundSize = '100% 100%';


    //randomise side to peep from
    var random = Math.floor(helpers.Randomizer(1,2.99));
    //random = 1;
    console.log(random);

    //var Note = createNote("../assets/img/music1.png");

    let height = helpers.Randomizer(0, innerHeight-400 );
    let times = 5;
    let Notes = [];

    switch (random) {
    case 1:
        // left        
        gsap.set(Div, { className: 'choon-element', x: -400, y: height, z:100 });

        
        for(var i = 0; i < times; i++){
            Notes[i] = createNote("../assets/img/music1.png");
            gsap.set(Notes[i], { className: 'note-element', x: helpers.Randomizer(0, 250), y: height+helpers.Randomizer(-200, 200), z:10, opacity: 0, scale: 0.01 });
            note_animation(Notes[i]);
            console.log(Notes[i]);
        }

        choon_animation_left(Div);

        break;
    case 2:
        // right
        gsap.set(Div, { className: 'choon-element', x: innerWidth+400, y: height, z:0  });

        for(var i = 0; i < times; i++){
            Notes[i] = createNote("../assets/img/music1.png");
            gsap.set(Notes[i], { className: 'note-element', x: helpers.Randomizer(innerWidth, innerWidth-350), y: height+helpers.Randomizer(-200, 200), z:10, opacity: 0, scale: 0.01 });
            note_animation(Notes[i]);
            console.log(Notes[i]);
        }

        choon_animation_right(Div); 
    
        break;
    }
    choon_globalConst.warp.appendChild(Div);

    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
    
    

}

function createNote(image) {
    var MNoteDiv = document.createElement('div');
    MNoteDiv.id = choon_globalVars.divnumber;
    choon_globalVars.divnumber++;
    MNoteDiv.style.background = 'url(' + 'img/music1.png' + ')';
    MNoteDiv.style.backgroundSize = '100% 100%';
    //MNoteDiv.classList.add('note_element');

    choon_globalConst.warp.appendChild(MNoteDiv);
    setTimeout(() => {
        helpers.removeelement(MNoteDiv.id);
    }, 15000);

    return MNoteDiv
}

function note_animation(element){

    //gsap.to(element, {duration: 2, opacity: 1, yoyo: false, repeat: 0, delay: 3, })
    //gsap.to(element, {duration: 1, rotationZ:'-=40', yoyo: false, repeat: 0, delay: 5})

    let verticalTravel = innerHeight / 2;
    let delay = helpers.Randomizer(3,6);
    //Fade In
    gsap.to(element, { opacity: 1, ease: Linear.easeNone, repeat: 0, delay: delay, duration: 4 });
    gsap.to(element, { scale: 1.25, ease: Linear.easeNone, repeat: 0, delay: delay, duration: 4 });
    //Vertical Movement
    // gsap.to(element, { y: `-=${verticalTravel}`, x: function() {
    //     return helpers.Randomizer(-250, 250) + gsap.getProperty(element, "x");
    // }, ease: Linear.easeNone, repeat: 0, delay: -1, duration: helpers.Randomizer(10, 20) });
    gsap.to(element, {
        duration: 5, // Duration of the animation in seconds
        delay: 3,
        ease: Linear.easeNone, // Easing function (you can choose a different one)
        "--hue-rotate": helpers.Randomizer(180,360), // Custom property to control hue rotation
        onUpdate: () => {
          // Update the filter property during the animation
          element.style.filter = `invert(44%) sepia(61%) saturate(1001%) brightness(99%) contrast(101%) hue-rotate(${gsap.getProperty(element, "--hue-rotate")}deg)`;
        }
      });

    //Fade Out
    gsap.to(element, {
        duration: 1, // Duration of the animation in seconds
        delay: delay + 4,
        ease: "power2.out", // Easing function (you can choose a different one)
        scale: 1.5, // Scale up the element
        opacity: 0, // Make the element disappear
        rotation: 360, // Rotate the element
        onComplete: () => {
          // Callback function when the animation is complete (optional)
          element.style.display = "none"; // Hide the element
        }
      });
    //gsap.to(element, { opacity: 0, ease: Linear.easeNone, repeat: 0, delay: helpers.Randomizer(9, 11) , duration: 4});

}

function choon_animation_left(element) {
    
    gsap.to(element, {duration: 6, x: '+=450'})
    gsap.to(element, {duration: 1, y: '-=50', yoyo: true, ease: Sine.easeInOut, repeat: 8})
    gsap.to(element, { opacity: 0, ease: Linear.easeNone, repeat: 0, delay: helpers.Randomizer(8, 10) , duration: 4});


    gsap.to(element, {
        duration: 1, // Duration of the animation in seconds
        delay: 10,
        ease: "power2.out", // Easing function (you can choose a different one)
        scale: 1.5, // Scale up the element
        opacity: 0, // Make the element disappear
        rotation: 360, // Rotate the element
        onComplete: () => {
          // Callback function when the animation is complete (optional)
          element.style.display = "none"; // Hide the element
        }
      });
    //gsap.to(element, {duration: 0.2, rotationZ:'-=20', yoyo: true, repeat: 23, repeatDelay: 0, delay: 0.2})
    //gsap.to(element, {duration: 0.2, rotationZ: 0, yoyo: false, repeat: 0, delay: 4.8})

}

function choon_animation_right(element){

    gsap.to(element, {duration: 6, x: '-=650'})
    gsap.to(element, {duration: 1, y: '-=50', yoyo: true, ease: Sine.easeInOut, repeat: 8})
    gsap.to(element, { opacity: 0, ease: Linear.easeNone, repeat: 0, delay: helpers.Randomizer(8, 10) , duration: 4});


    gsap.to(element, {
        duration: 1, // Duration of the animation in seconds
        delay: 10,
        ease: "power2.out", // Easing function (you can choose a different one)
        scale: 1.5, // Scale up the element
        opacity: 0, // Make the element disappear
        rotation: 360, // Rotate the element
        onComplete: () => {
          // Callback function when the animation is complete (optional)
          element.style.display = "none"; // Hide the element
        }
      });
}
;// CONCATENATED MODULE: ./src/animations/cheers.js

const { globalVars: cheers_globalVars, globalConst: cheers_globalConst} = config;



/*
Large Beer image fade in
Drops sender and target (or me) into the beer.
Floats/bounces around then all fade out
*/

function cheers_create(images) {

    let imgcount = images.length;
    let interval = 250;
    let basewidth = helpers.Randomizer(innerWidth/2-50, innerWidth/2+50, );
    let xPos = [basewidth, basewidth-175];
    let drop = [innerHeight-500, innerHeight-600];

    for (let j = 0; j < images.length; j++) {
        // split the count amounst the images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createAvatarDivs(images[imagenum], xPos[imagenum], drop[imagenum]);
        }, j * interval);
    }

    var BeerDiv = document.createElement('div');
    BeerDiv.id = cheers_globalVars.divnumber;
    cheers_globalVars.divnumber++;
    //BeerDiv.style.background = 'url(' + 'img/beer.jpg' + ')';
    BeerDiv.style.backgroundSize = '100% 100%';
    gsap.set(BeerDiv, {className: 'beer-glass', x: innerWidth/2 , y: 0, z:0, opacity: 0, transformOrigin:"center", xPercent: -50});
    

    cheers_globalConst.warp.appendChild(BeerDiv);

    beer_animation(BeerDiv);


    const video = document.createElement('video');
    video.src = 'img/beerpourV2_VP9.webm'; // Replace with your video URL
    video.autoplay = true;
    video.muted = true; // Autoplay requires muted for some browsers
    video.loop = true;
    video.controls = false;

    video.style.width = '100%';
    video.style.height = '100%';

    BeerDiv.appendChild(video);

    // Run animation
    
    setTimeout(() => {
        helpers.removeelement(BeerDiv.id);
    }, 15000);

}

function createAvatarDivs(image, xPos, drop){

    var Div = document.createElement('div');
    Div.id = cheers_globalVars.divnumber;
    cheers_globalVars.divnumber++;
    Div.style.background = 'url(' + image + ')';
    Div.style.backgroundSize = '100% 100%';

    gsap.set(Div, {className: 'beer-avatar', x: xPos, y: -250, z:10, scale: 0.8, transformOrigin:"50% 50%" });

    cheers_globalConst.warp.appendChild(Div);

    drop_animation(Div, drop);

    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}

function drop_animation(element, drop) {

    gsap.to(element, {
        rotation: helpers.Randomizer(-15,15),
        delay: 1,
        duration: 4,
        ease: "sine.inOut",
    });

    gsap.to(element, {
        duration: 1.5, // Duration of the fall
        delay: 3,
        y: drop, // Fall to 75% of the container's height
        
        ease: "power1.out", // Easing function (you can choose a different one)
        onComplete: () => {
          // Callback when the drop reaches the bottom
          gsap.to(element, {
            duration: 1.45, // Duration of the bobble
            y: drop-175, // Bobble up to 60% of the container's height
            yoyo: true, // Yoyo effect for bouncing
            repeat: 1, // Repeat indefinitely
            ease: "sine.inOut", // Easing function for the bobble
            onComplete: () => {
                gsap.to(element, {
                    duration: 1.55, // Duration of the bobble
                    y: drop-125, // Bobble up to 60% of the container's height
                    yoyo: true, // Yoyo effect for bouncing
                    repeat: 1, // Repeat indefinitely
                    ease: "sine.inOut", // Easing function for the bobble
                    onComplete: () => {
                        fadeout(element);
                        gsap.to(element, {
                            duration: 1.65, // Duration of the bobble
                            y: drop-100, // Bobble up to 60% of the container's height
                            yoyo: true, // Yoyo effect for bouncing
                            repeat: 1, // Repeat indefinitely
                            ease: "sine.inOut", // Easing function for the bobble
                        });
                    }
                });
            }
          });
        }
      });
}

function fadeout(element){
    gsap.to(element, {
        duration: 4, // Duration of the bobble
        opacity: 0,
        yoyo: false, // Yoyo effect for bouncing
        repeat: 0, // Repeat indefinitely
        ease: "sine.inOut", // Easing function for the bobble
    });
}

function beer_animation(element){

    gsap.to(element, {opacity: 1, duration: 2, delay: 0})
    gsap.to(element, {opacity: 0, duration: 2, delay: 13})
}

;// CONCATENATED MODULE: ./src/animations/invaders.js

const { globalVars: invaders_globalVars, globalConst: invaders_globalConst} = config;


function emoteInvaders (images, count=56, interval=50) {
    let imgcount = images.length;
    if(count > 256){
      count = 256;
    }
  
    const containerWidth = innerWidth - 800; // Replace with the actual width of the container element
    const containerHeight = innerHeight - 400; 
  
    const numRows = Math.ceil(Math.sqrt(count));
    const numCols = Math.ceil(count / numRows);
  
    console.log(numRows);
    console.log(numCols);
  
    const cellWidth = containerWidth / numCols;
    const cellHeight = containerHeight / numRows;
  
    for (let j = 0; j < count; j++) {
      // split the count amounst the different emote images
      let imagenum = j % imgcount;
  
      const row = Math.floor(j / numCols);
      const col = j % numCols;
      const x = col * cellWidth;
      const y = row * cellHeight;
  
      let Div = document.createElement('div');
      Div.id = invaders_globalVars.divnumber;
      invaders_globalVars.divnumber++;
  
      console.log(x);
      console.log(y);
      console.log(cellWidth);
      console.log(cellHeight);
  
      gsap.set(Div, { x: x+50, y, width: cellWidth, height: cellHeight, className: 'invader-element', backgroundSize: cellHeight - 20, backgroundImage: 'url(' + images[imagenum] + ')' });
      invaders_globalConst.warp.appendChild(Div);
      //var createcommand = 'createemoteInvaders("' + images[imagenum] + '")';
      //setTimeout(createcommand, (j * interval));
      setTimeout(() => {
        helpers.removeelement(Div.id);
      }, 70000);
    }
  
    invaders_animation();
  
  }
  
  function invaders_animation() {
    const invaders = document.querySelectorAll('.invader-element');
  
    // create a timeline for the animation
    const tl = gsap.timeline({ repeat: 50, repeatRefresh: true });
  
    // set the initial duration
    const initialDuration = 1;
  
    // add tweens to the timeline to create the space invaders movement
    tl.to(invaders, { x: '+=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { x: '+=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { x: '+=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { x: '+=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { y: '+=75', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { x: '-=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { x: '-=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { x: '-=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { x: '-=200', duration: initialDuration, onComplete: shortenDuration })
      .to(invaders, { y: '+=75', duration: initialDuration, onComplete: shortenDuration });
  
      function shortenDuration() {
        // get the current duration
        const currentDuration = tl.getChildren()[0].duration();
  
        // calculate the new duration
        const newDuration = currentDuration * 0.80;
  
        // set the new duration
        tl.getChildren().forEach(child => child.duration(newDuration));
      }
    
    // start the animation
    tl.play();
  
  }
;// CONCATENATED MODULE: ./src/animations/raiders.js

const { globalVars: raiders_globalVars, globalConst: raiders_globalConst} = config;




//TWITCH HAS DEPRECATED THE IDs of each raider so this code doesn't work anymore

//TODO: Replace with raid animation where raiding user is shown, with an army of default people icons, charging across the screen


async function incomingRaid(userId, displayName, viewers){
    console.log(userId);
    console.log(displayName);
    console.log(viewers);

    let avatar;

    try {
        avatar = await helpers.getTwitchAvatar(userId, true);
    } catch (error) {
        console.error(error);
        throw error;
    }
    

    console.log(avatar);

    //Setup the raid wrapper
    let raidWrapper = document.createElement('div');
    raidWrapper.id = setTimeout(() => {
        helpers.removeelement(raidWrapper.id);
    }, 600000);
    gsap.set(raidWrapper, { className: 'raid-wrapper', position: "absolute", height: innerHeight, width: innerWidth, x: 0, y: 0, z: helpers.Randomizer(-200, 200), });
    raiders_globalConst.warp.appendChild(raidWrapper);


    // Calculate the number of rows and columns in the pyramid
    let numRows = Math.ceil(Math.sqrt(viewers));
    let numCols = numRows;

    // Calculate the width and height of each pyramid element
    let elementWidth = 50;
    let elementHeight = 50;
    let spacing = 10;

    // Calculate the total width of each row
    let rowWidth = numCols * (elementWidth + spacing) - spacing;



    //lead raider
    let raider = document.createElement("div");
    raider.className = "raider-element";
    raider.style.width = elementWidth * 2 + "px";
    raider.style.height = elementHeight * 2 + "px";
    
    // Position the raider
    let xPos = innerHeight / 2;
    let yPos = (numRows - 1) * (elementHeight + spacing);
    raider.style.top = xPos + "px";
    raider.style.left = yPos + "px";
    
    // Append the raider to the container
    gsap.set(raider, { className: 'raider-leader', z: 10, zIndex: 10, position: "absolute", backgroundImage: 'url(' + avatar + ')' });
    raidWrapper.appendChild(raider);

    //raiderAnimation(raider);

    // Loop through the rows and columns to create and position each element
    for (let row = numRows - 1; row >= 0; row--) {
        let rowStartX = (rowWidth - (numCols * (elementWidth + spacing) - spacing)) / 2;

        for (let col = 0; col < numCols; col++) {
            let element = document.createElement("div");
            element.className = "raider-element";
            element.style.width = elementWidth + "px";
            element.style.height = elementHeight + "px";
            
            // Position the element
            let xPos = rowStartX + col * (elementWidth + spacing);
            let yPos = (numRows - 1 - row) * (elementHeight + spacing);
            element.style.top = xPos + "px";
            element.style.left = yPos + "px";
            
            // Append the element to the container
            gsap.set(element, { className: 'raider-image', z: 10, zIndex: 10, position: "absolute", backgroundImage: 'url(' + avatar + ')' });
            raidWrapper.appendChild(element);

            //raiderAnimation(element);
            console.log("raider added");
        }
    numCols--;
    }

    // Use GSAP animations if needed
    //gsap.set(".pyramid-element", { opacity: 0, y: -50, stagger: 0.1 });
        

    return
}

function createRaider(image){
    var Div = document.createElement('div');
    Div.id = divnumber;
    divnumber++;
    Div.style.background = 'url(' + image + ')';
    Div.style.backgroundSize = '100% 100%';


    TweenLite.set(Div, { className: 'raider-element', x: helpers.Randomizer(-400, -100), y: helpers.Randomizer(0, innerHeight), z:100 });

    raiders_globalConst.warp.appendChild(Div);

    raiderAnimation(Div);

    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 50000);

}

function raiderAnimation(element){
    //gsap.to(element, {y: "+=100", duration: 1, yoyo: true, repeat: 25, ease: "sine.inOut"});
    
    gsap.to(element, {rotation: "-=20", duration: 0.25, ease: "sine.inOut"});
    gsap.to(element, {rotation: "+=40", delay: 0.25, duration: 0.5, yoyo: true, repeat: 50, ease: "sine.inOut"});
    gsap.to(element, {duration: 8, x: helpers.Randomizer(innerWidth+100, innerWidth+400), yoyo: true, repeat: 1, repeatDelay: 5});

    let width = helpers.Randomizer(1, innerWidth); //0,1920
    let middle = innerWidth / 2; //980
    let height;

    if(width > middle){
    let newwidth = width - 980;

    height = 300 - newwidth/middle * 200;
    console.log(newwidth/middle * 200);
    console.log(height);
    }
    else {
    height = 100 + width/middle * 200;
    console.log(width/middle * 200);
    console.log(height);
    }
    
    gsap.to(element, {duration: 0, x: width, y: innerHeight+100, delay: 26});
    gsap.to(element, {duration: 2, y: innerHeight-height, delay: 27});
    gsap.to(element, {duration: 5, opacity: 0, delay: 29});
   

    //var tl2 = gsap.timeline({ repeat: 2, defaults: { duration: flipTime, ease: "none" } })
    //tl2.to(element, {duration: 6, x: innerWidth + 200});
    //tl2.to(element, {duration: 6, x: -200, delay: 5});

    //tl2.resume();
}
;// CONCATENATED MODULE: ./src/animations/fade.js

const { globalVars: fade_globalVars, globalConst: fade_globalConst} = config;



function fade_create(images, count=10, interval=150) {
    
    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createDivs(images[imagenum]);
        }, j * interval);
    }
}


function createDivs(image) {
    var Div = document.createElement('div');
    Div.id = fade_globalVars.divnumber;
    fade_globalVars.divnumber++;

    gsap.set(Div, { className: 'fade-element', x: helpers.Randomizer(0, innerWidth), y: helpers.Randomizer(0, innerHeight), z: helpers.Randomizer(-200, 200), scale: 0.1 , opacity: 0, backgroundImage: 'url(' + image + ')' });

    fade_globalConst.warp.appendChild(Div);

    // Run animation
    animation(Div);
    //Destroy element after 8 seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);
}




// Rising animation
function animation(element) {
    //Fade In
    gsap.to(element, { opacity: 1, ease: Linear.easeNone, repeat: 0, delay: 1, duration: 3 });
    gsap.to(element, { scale: 2.5, ease: Linear.easeNone, repeat: 0, delay: 1, duration: 6 });
    gsap.to(element, { opacity: 0, ease: Linear.easeNone, repeat: 0, delay: 4, duration: 4 });
    
}
;// CONCATENATED MODULE: ./src/animations/cyclone.js

const { globalVars: cyclone_globalVars, globalConst: cyclone_globalConst} = config;


function emoteCyclone(images, count=100, interval=30) {

    let imgcount = images.length;

    for (let j = 0; j < count; j++) {
        // split the count amounst the images
        let imagenum = j % imgcount;
        setTimeout(() => {
            createEmoteCyclone(images[imagenum]);
        }, j * interval);
    }
}

function createEmoteCyclone(image) {

    var Div = document.createElement('div');
    Div.id = cyclone_globalVars.divnumber;
    cyclone_globalVars.divnumber++;

    gsap.set(Div, { className: 'cyclone-element', x: innerWidth/2, y: innerHeight, z: helpers.Randomizer(-200, 200), backgroundImage: 'url(' + image + ')' });

    cyclone_globalConst.warp.appendChild(Div);

    // Run animation
    cyclone_animation(Div);
    //Destroy element after X seconds so we don't eat up resources over time!
    setTimeout(() => {
        helpers.removeelement(Div.id);
    }, 15000);

}

// Explosion Animation
function cyclone_animation(element) {
    let centerX = innerWidth / 2;
    let startY = innerHeight;
    
    // Get random starting position on the circle
    let startAngle = helpers.Randomizer(0, 360);
    let angleRad = (startAngle * Math.PI) / 180;
    
    // Initial radius is 8% of screen width
    const initialRadius = innerWidth * 0.08;
    
    // Set initial position
    gsap.set(element, {
        x: centerX + Math.cos(angleRad) * initialRadius,
        y: startY,
        rotation: startAngle
    });

    // Create a timeline for smoother animation
    let tl = gsap.timeline();
    
    // Calculate single segment duration and overlap
    const segmentDuration = 0.8;
    const overlap = 0.4;
    // Total duration = (segmentDuration - overlap) * (number of segments - 1) + segmentDuration
    const totalDuration = (segmentDuration - overlap) * 7 + segmentDuration; // About 2.8 seconds

    // Add each segment to the timeline with position parameter for overlap
    tl.to(element, {
        x: centerX + Math.cos(angleRad + Math.PI/4) * (innerWidth * 0.10),
        y: startY - (innerHeight * 0.1),
        rotation: startAngle + 90,
        scale: 1.05,
        duration: segmentDuration,
        ease: "none"
    })
    .to(element, {
        x: centerX + Math.cos(angleRad + Math.PI/2) * (innerWidth * 0.14),
        y: startY - (innerHeight * 0.25),
        rotation: startAngle + 180,
        scale: 1.1,
        duration: segmentDuration,
        ease: "none"
    }, "-=0.4")  // Start 0.4s before previous tween ends
    .to(element, {
        x: centerX + Math.cos(angleRad + Math.PI*3/4) * (innerWidth * 0.18),
        y: startY - (innerHeight * 0.4),
        rotation: startAngle + 270,
        scale: 1.15,
        duration: segmentDuration,
        ease: "none"
    }, "-=0.4")
    .to(element, {
        x: centerX + Math.cos(angleRad + Math.PI) * (innerWidth * 0.22),
        y: startY - (innerHeight * 0.5),
        rotation: startAngle + 360,
        scale: 1.2,
        duration: segmentDuration,
        ease: "none"
    }, "-=0.4")
    .to(element, {
        x: centerX + Math.cos(angleRad + Math.PI*5/4) * (innerWidth * 0.24),
        y: startY - (innerHeight * 0.6),
        rotation: startAngle + 450,
        scale: 1.25,
        duration: segmentDuration,
        ease: "none"
    }, "-=0.4")
    .to(element, {
        x: centerX + Math.cos(angleRad + Math.PI*3/2) * (innerWidth * 0.26),
        y: startY - (innerHeight * 0.7),
        rotation: startAngle + 540,
        scale: 1.3,
        duration: segmentDuration,
        ease: "none"
    }, "-=0.4")
    .to(element, {
        x: centerX + Math.cos(angleRad + Math.PI*7/4) * (innerWidth * 0.28),
        y: startY - (innerHeight * 0.75),
        rotation: startAngle + 630,
        scale: 1.35,
        duration: segmentDuration,
        ease: "none"
    }, "-=0.4")
    .to(element, {
        x: centerX + Math.cos(angleRad + Math.PI*2) * (innerWidth * 0.3),
        y: startY - (innerHeight * 0.8),
        rotation: startAngle + 720,
        scale: 1.4,
        duration: segmentDuration,
        ease: "none"
    }, "-=0.4");

    // Add fade out that starts before motion completes
    gsap.to(element, {
        opacity: 0,
        duration: 1.5,
        ease: "power2.in",
        delay: totalDuration - 1 // Start fading 1 second before motion completes
    });
}

;// CONCATENATED MODULE: ./src/lib/emotetetris.js
const tetrisDist = {
    'L1': [
     [0, 0, 1, 0],
     [1, 1, 1, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'L2': [
     [1, 0, 0, 0],
     [1, 0, 0, 0],
     [1, 1, 0, 0],
     [0, 0, 0, 0]
    ],
    'L3': [
     [1, 1, 1, 0],
     [1, 0, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'L4': [
     [1, 1, 0, 0],
     [0, 1, 0, 0],
     [0, 1, 0, 0],
     [0, 0, 0, 0]
    ],
    'P1': [
     [1, 0, 0, 0],
     [1, 1, 1, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'P2': [
     [1, 1, 0, 0],
     [1, 0, 0, 0],
     [1, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'P3': [
     [1, 1, 1, 0],
     [0, 0, 1, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'P4': [
     [0, 1, 0, 0],
     [0, 1, 0, 0],
     [1, 1, 0, 0],
     [0, 0, 0, 0]
    ],
    'Z1': [
     [1, 1, 0, 0],
     [0, 1, 1, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'Z2': [
     [0, 1, 0, 0],
     [1, 1, 0, 0],
     [1, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'Z3': [
     [1, 1, 0, 0],
     [0, 1, 1, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'Z4': [
     [0, 1, 0, 0],
     [1, 1, 0, 0],
     [1, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'S1': [
     [0, 1, 1, 0],
     [1, 1, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'S2': [
     [1, 0, 0, 0],
     [1, 1, 0, 0],
     [0, 1, 0, 0],
     [0, 0, 0, 0]
    ],
    'S3': [
     [0, 1, 1, 0],
     [1, 1, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'S4': [
     [1, 0, 0, 0],
     [1, 1, 0, 0],
     [0, 1, 0, 0],
     [0, 0, 0, 0]
    ],
    'T1': [
     [0, 1, 0, 0],
     [1, 1, 1, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'T2': [
     [1, 0, 0, 0],
     [1, 1, 0, 0],
     [1, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'T3': [
     [1, 1, 1, 0],
     [0, 1, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'T4': [
     [0, 1, 0, 0],
     [1, 1, 0, 0],
     [0, 1, 0, 0],
     [0, 0, 0, 0]
    ],
    'I1': [
     [1, 0, 0, 0],
     [1, 0, 0, 0],
     [1, 0, 0, 0],
     [1, 0, 0, 0]
    ],
    'I2': [
     [1, 1, 1, 1],
     [0, 0, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'I3': [
     [1, 0, 0, 0],
     [1, 0, 0, 0],
     [1, 0, 0, 0],
     [1, 0, 0, 0]
    ],
    'I4': [
     [1, 1, 1, 1],
     [0, 0, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'Q1': [
     [1, 1, 0, 0],
     [1, 1, 0, 0],
     [0, 0, 0, 0],
     [0, 0, 0, 0]
    ],
    'Q2': [
    [1, 1, 0, 0],
    [1, 1, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
    ],
    'Q3': [
    [1, 1, 0, 0],
    [1, 1, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
    ],
    'Q4': [
    [1, 1, 0, 0],
    [1, 1, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
    ],
   };



   // L
   // P
   // Z
   // S
   // T
   // I
   // Q


;// CONCATENATED MODULE: ./src/animations/tetris.js

const { globalVars: tetris_globalVars, globalConst: tetris_globalConst} = config;



function emoteTetris(images, pieces=20, interval=100) {
    // Initialize game grid (20 rows x 10 columns)
    const GRID_HEIGHT = 20;
    const GRID_WIDTH = 10;
    let grid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));
    
    // Create grid container
    const gridContainer = document.createElement('div');
    gridContainer.id = 'tetris-grid-' + tetris_globalVars.divnumber++;
    gridContainer.className = 'tetris-grid';
    tetris_globalConst.warp.appendChild(gridContainer);
    
    // Style the grid container - align to bottom of screen
    gsap.set(gridContainer, {
        position: 'absolute',
        left: '50%',
        bottom: '32px', // Add some padding from bottom
        transform: 'translateX(-50%)',
        width: GRID_WIDTH * 32 + 'px',  // 32px per cell
        height: GRID_HEIGHT * 32 + 'px',
        display: 'grid',
        gridTemplateColumns: `repeat(${GRID_WIDTH}, 32px)`,
        gridTemplateRows: `repeat(${GRID_HEIGHT}, 32px)`,
        gap: '0px'
    });

    // Create grid cells
    for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
            const cell = document.createElement('div');
            cell.className = 'tetris-cell';
            cell.id = `tetris-${gridContainer.id}-${y}-${x}`;
            gridContainer.appendChild(cell);
            
            gsap.set(cell, {
                width: '32px',
                height: '32px',
                backgroundColor: 'transparent'
            });
        }
    }
    
    // Get all possible piece types (L, P, Z, S, T, I, Q)
    const pieceTypes = Object.keys(tetrisDist).filter(key => key.endsWith('1')).map(key => key[0]);
    
    // Track current animation state
    let currentPiece = null;
    let currentPiecePos = { x: 0, y: 0 };
    let piecesPlaced = 0;
    let currentImageIndex = 0;
    
    function getRandomPiece() {
        const type = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
        const rotation = Math.floor(Math.random() * 4) + 1;
        return tetrisDist[`${type}${rotation}`];
    }
    
    function getPieceWidth(piece) {
        let width = 0;
        for (let x = 0; x < 4; x++) {
            for (let y = 0; y < 4; y++) {
                if (piece[y][x]) width = Math.max(width, x + 1);
            }
        }
        return width;
    }
    
    function updateCell(x, y, image) {
        if (y >= 0 && y < GRID_HEIGHT && x >= 0 && x < GRID_WIDTH) {
            const cell = document.getElementById(`tetris-${gridContainer.id}-${y}-${x}`);
            if (cell) {
                if (image) {
                    gsap.set(cell, {
                        backgroundImage: `url(${image})`,
                        backgroundSize: 'contain',
                        backgroundPosition: 'center',
                        backgroundRepeat: 'no-repeat'
                    });
                } else {
                    gsap.set(cell, { clearProps: 'background' });
                }
            }
        }
    }
    
    function renderGrid() {
        // Clear grid
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                updateCell(x, y, grid[y][x]);
            }
        }
        
        // Render current piece
        if (currentPiece) {
            const image = images[currentImageIndex];
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (currentPiece[y][x] && currentPiecePos.y + y >= 0) {
                        updateCell(currentPiecePos.x + x, currentPiecePos.y + y, image);
                    }
                }
            }
        }
    }
    
    function canPlacePiece(piece, pos) {
        for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
                if (piece[y][x]) {
                    const newX = pos.x + x;
                    const newY = pos.y + y;
                    
                    if (newX < 0 || newX >= GRID_WIDTH || newY >= GRID_HEIGHT) {
                        return false;
                    }
                    
                    if (newY >= 0 && grid[newY][newX] !== null) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    function placePiece(piece, pos) {
        const image = images[currentImageIndex];
        currentImageIndex = (currentImageIndex + 1) % images.length;
        
        for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
                if (piece[y][x] && pos.y + y >= 0) {
                    grid[pos.y + y][pos.x + x] = image;
                }
            }
        }
        
        // Check for completed rows
        checkForCompletedRows();
    }
    
    function checkForCompletedRows() {
        const completedRows = [];
        
        // Find completed rows
        for (let y = 0; y < GRID_HEIGHT; y++) {
            if (grid[y].every(cell => cell !== null)) {
                completedRows.push(y);
            }
        }
        
        if (completedRows.length > 0) {
            // Animate row explosion
            animateRowExplosion(completedRows);
        }
    }
    
    function animateRowExplosion(rows) {
        // Pause the main game loop temporarily
        const originalPiece = currentPiece;
        const originalPos = {...currentPiecePos};
        currentPiece = null;
        
        // Get cells from completed rows for animation
        const cellsToAnimate = [];
        rows.forEach(rowIndex => {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const cell = document.getElementById(`tetris-${gridContainer.id}-${rowIndex}-${x}`);
                cellsToAnimate.push(cell);
            }
        });
        
        // Flash effect
        const timeline = gsap.timeline({
            onComplete: () => {
                // Remove completed rows and shift pieces down
                removeCompletedRows(rows);
                // Resume the game
                currentPiece = originalPiece;
                currentPiecePos = originalPos;
                renderGrid();
            }
        });
        
        // Flash white 3 times
        timeline.to(cellsToAnimate, {
            backgroundColor: "white",
            duration: 0.1
        })
        .to(cellsToAnimate, {
            backgroundColor: "transparent",
            duration: 0.1
        })
        .to(cellsToAnimate, {
            backgroundColor: "white",
            duration: 0.1
        })
        .to(cellsToAnimate, {
            backgroundColor: "transparent",
            duration: 0.1
        })
        .to(cellsToAnimate, {
            backgroundColor: "white",
            duration: 0.1
        });
        
        // Explosion effect: scale and fade out
        timeline.to(cellsToAnimate, {
            scale: 1.5,
            opacity: 0,
            duration: 0.2,
            stagger: 0.02,
            ease: "power1.out"
        });
    }
    
    function removeCompletedRows(rows) {
        // Sort rows in descending order to handle multiple rows properly
        rows.sort((a, b) => b - a);
        
        rows.forEach(rowIndex => {
            // Remove the completed row
            grid.splice(rowIndex, 1);
            // Add a new empty row at the top
            grid.unshift(Array(GRID_WIDTH).fill(null));
        });
    }
    
    function spawnNewPiece() {
        currentPiece = getRandomPiece();
        const pieceWidth = getPieceWidth(currentPiece);
        currentPiecePos = {
            x: Math.floor(Math.random() * (GRID_WIDTH - pieceWidth + 1)), // Random position across full width
            y: -4
        };
        piecesPlaced++;
    }
    
    function update() {
        if (!currentPiece) {
            spawnNewPiece();
        }
        
        // Try moving piece down
        const nextPos = { ...currentPiecePos, y: currentPiecePos.y + 1 };
        
        if (canPlacePiece(currentPiece, nextPos)) {
            currentPiecePos = nextPos;
        } else {
            // Place piece and spawn new one
            placePiece(currentPiece, currentPiecePos);
            currentPiece = null;
        }
        
        renderGrid();
        
        // Continue animation if pieces remain
        if (piecesPlaced < pieces) {
            setTimeout(update, interval);
        } else {
            // Fade out and clean up after animation is done
            gsap.to(gridContainer, {
                opacity: 0,
                duration: 1,
                ease: "power2.out",
                onComplete: () => {
                    helpers.removeelement(gridContainer.id);
                }
            });
        }
    }
    
    // Start animation
    update();
}
;// CONCATENATED MODULE: ./src/animations.js

const { globalVars: animations_globalVars, globalConst: animations_globalConst} = config;

























const animations = {
  firework: firework_namespaceObject,
  rain: rain_namespaceObject,
  explode: explode_namespaceObject,
  rise: rise_namespaceObject,
  lurking: lurking_namespaceObject,
  comets: comets_namespaceObject,
  bounce: bounce_namespaceObject,
  spiral: spiral_namespaceObject,
  waves: waves_namespaceObject,
  carousel: carousel_namespaceObject,
  volcano: volcano_namespaceObject,
  text: text_namespaceObject,
  dvd: dvd_namespaceObject,
  coinflip: coinflip_namespaceObject,
  cube: cube_namespaceObject,
  hypetrain: hypetrain_namespaceObject,
  choon: choon_namespaceObject,
  cheers: cheers_namespaceObject,
  invaders: invaders_namespaceObject,
  raiders: raiders_namespaceObject,
  fade: fade_namespaceObject,
  cyclone: cyclone_namespaceObject,
  tetris: tetris_namespaceObject
}


// function runAnimation(functionName, images, eCount, eInterval) {
//     // Execute the function dynamically using the mapping object
//     const animationFunction = animationFunctions[functionName];
//     if (typeof animationFunction === 'function') {
//       animationFunction(images, eCount, eInterval);
//     } else {
//       console.error(`Function '${functionName}' does not exist.`);
//     }
//   }


/* harmony default export */ const src_animations = (animations);

;// CONCATENATED MODULE: ./src/handlers.js

const { globalVars: handlers_globalVars, globalConst: handlers_globalConst} = config;



//import posthog from 'posthog-js';

function chatMessageHandler(wsdata) {
    var message = wsdata.data.message.message
    var lowermessage = wsdata.data.message.message.toLowerCase();
    var username = wsdata.data.message.username;
    var userId = wsdata.data.message.userId;

    //Lurk
    if (lowermessage.includes("!lurk")) {
      if(!handlers_globalConst.lurk && !handlers_globalConst.all){
        console.log("Lurk Not Enabled");
        return
      }
      lurkCommand(username);
    }

    //Shoutout
    if (lowermessage.includes("!so")) {
      if(!handlers_globalConst.welcome && !handlers_globalConst.all){
        console.log("Shoutout Not Enabled");
        return
      }
      shoutoutCommand(lowermessage);
    }

    //Choon
    if (lowermessage.includes("!choon") || lowermessage.includes("!tune")) {
      if(!handlers_globalConst.all && !handlers_globalConst.choon){
        console.log("Choon Command Not Enabled");
        return
      }
      choonCommand(username);
    }

    //Cheers
    if (lowermessage.includes("!cheers")) {
      if(!handlers_globalConst.all && !handlers_globalConst.cheers){
        console.log("Cheers Command Not Enabled");
        return
      }

      let targetuser;

      if(lowermessage.includes("@")){
        let split = lowermessage.split('@');
        targetuser = split[1];

      }
      cheersCommand(username, targetuser);
    }

    //Join Hype Train Command for Testing
    if (lowermessage.includes("!jointrain")) {
      if(!debug){
        console.log("Cheers Command Not Enabled");
        return
      }
      src_animations.hypetrain.hypetrainprogression(userId);
    }

    //TestCommand: 
    //emoteVolcano(['https://static-cdn.jtvnw.net/emoticons/v2/emotesv2_2758558107d148c9b1e73c56cb2d9e06/default/dark/2.0', 'https://static-cdn.jtvnw.net/emoticons/v2/emotesv2_dcaf0a56231d4443a91546b869b96a25/default/dark/2.0'], 100, 20);

    if (typeof wsdata.data.message.emotes != "undefined") {
      emoteMessageHandler(wsdata);
    }
  }

function actionsHandler(wsdata){
  let data = wsdata.data;
  let action = wsdata.data.name;

}

function emoteMessageHandler(wsdata){
  var message = wsdata.data.message.message
  var lowermessage = wsdata.data.message.message.toLowerCase();
  var userrole = wsdata.data.message.role;
  var sub = wsdata.data.message.subscriber;
  var emotecount = wsdata.data.message.emotes.length;

  var images = [];
  var i;
  for (i = 0; i < emotecount; i++) {
    images[i] = wsdata.data.message.emotes[i].imageUrl;
  }


  var eInterval = helpers.getCommandValue(lowermessage, "interval");
  var eCount = helpers.getCommandValue(lowermessage, "count");

  if(eCount != null) {
  if(eCount > handlers_globalConst.maxemotes){
      eCount = handlers_globalConst.maxemotes;           
  }
  }

  //TextCommand, FunctionName, DefaultEmotes, DefaultInterval
  let animationMap = [
  ['!er rain','emoteRain', 50, 50, 'rain'],
  ['!er rise', 'emoteRise', 100, 50, 'rise'],
  ['!er explode', 'emoteExplode', 100, 20, 'explode'],
  ['!er volcano', 'emoteVolcano', 100, 20, 'volcano'],
  ['!er firework', 'emoteFirework', 100, 20, 'firework'],
  ['!er rightwave', 'emoteRightWave', 100, 20, 'waves'],
  ['!er leftwave', 'emoteLeftWave', 100, 20, 'waves'],
  ['!er carousel', 'emoteCarousel', 100, 150, 'carousel'],
  ['!er spiral', 'emoteSpiral', 100, 170, 'spiral'],
  ['!er comets', 'emoteComets', 100, 50, 'comets'],
  ['!er dvd', 'emoteDVD', 8, 50, 'dvd'],
  ['!er text', 'emoteText', 'HYPE', 25, 'text'],
  ['!er cyclone', 'emoteCyclone', 100, 30, 'cyclone'],
  ['!er tetris', 'emoteTetris', 50, 40, 'tetris']
  //['!er cube', 'emoteCube', 8, 50],
  ];



  //Specific Animation Commands
  if (handlers_globalConst.emoterain){
    if (handlers_globalConst.subonly & !sub) {
      console.log("Sub Only Mode enabled, Messsage was not from a Sub");
      return
    }
  }


  animationMap.forEach(function (animation) {
    if (!lowermessage.startsWith(animation[0])) {
      return
    }

    if(!eCount){eCount = animation[2];}
    if(!eInterval){eInterval = animation[3]}

    //EmoteText Specific Handling
    if(animation[1] == "emoteText") {
        let regexp = /text (\S*)/gm;  
        let matches = regexp.exec(wsdata.data.message.message);
        eCount = matches[1];

        if(wsdata.data.message.emotes.length < 1 && Botchat){
        let message = "Invalid Syntax, please try using '!er text <WordToWrite> <Emotes to use>'"
        botChat(message);
        }

        //Ensure that text was supplied by checking if the text string matches the first emote
        let emotenames = "";
        for(const emote of wsdata.data.message.emotes) {
        emotenames = emotenames + emote["name"] + " ";
        }
        //Set Default Text if no text supplied
        if(emotenames.includes(eCount)){
        eCount = "Hype";
        }                
    }

    
    console.log("running " + animation[1] + " with " + eCount + " emote(s)" + " and interval " + eInterval + ". module: " + animation[4]);
    if (src_animations.hasOwnProperty(animation[4]) && src_animations[animation[4]].hasOwnProperty(animation[1]) && typeof src_animations[animation[4]][animation[1]] === 'function'){
      src_animations[animation[4]][animation[1]](images, eCount, eInterval);
    } else {
      console.log("Animation Function Mapping Failed");
    }

      
  });
  


  //Kappagen Animations
  if (handlers_globalConst.kappagen){
    if (handlers_globalConst.subonly & !sub) {
      console.log("Sub Only Mode enabled, Messsage was not from a Sub");
      return
  }

  if(lowermessage.includes("!k ")) {
      let rAnimation = Math.round(helpers.Randomizer(0,animationMap.length - 1 ));
      if(!eCount){eCount = animationMap[rAnimation][2];}
      if(!eInterval){eInterval = animationMap[rAnimation][3];}

      let aniModule = animationMap[rAnimation][4];
      let aniFunction = animationMap[rAnimation][1];
      
      console.log("Rolled: " + rAnimation + ". Running: " + aniModule + " : " + aniFunction + " with " + eCount + " emote(s)" + " and interval " + eInterval);
      if (src_animations.hasOwnProperty(aniModule) && src_animations[aniModule].hasOwnProperty(aniFunction) && typeof src_animations[aniModule][aniFunction] === 'function'){
        src_animations[aniModule][aniFunction](images, eCount, eInterval);
      } else {
        console.log("Animation Function Mapping Failed");
      }
  }

}

  //Normal emotes animations
  let randomAnimation = Math.round(helpers.Randomizer(1,3));
    switch(randomAnimation) {
    case 1:
        src_animations.rain.emoteRain(images, emotecount);
        break;

    case 2:  
        src_animations.bounce.emoteBounce(images, emotecount);
        break;
    case 3:
        src_animations.fade.create(images, emotecount);
  };
}

function firstWordsHander(wsdata){
    if(!handlers_globalConst.welcome && !handlers_globalConst.all){
    console.log("First Words Not Enabled");
    return
    }
    
    var username = wsdata.data.message.username;
    var xhttp = new XMLHttpRequest();
    console.log("created xmlhttp object");
    xhttp.onreadystatechange = function () {
    if (this.readyState == 4 && this.status == 200) {
        // get display image for the user
        console.log("got a user image response back");
        
        let avatar = [xhttp.responseText];
        //Trigger Animation
        src_animations.rain.emoteRain(avatar, handlers_globalConst.defaultemotes, 50);

    }
    };
    console.log(username);
    xhttp.open("GET", "https://decapi.me/twitch/avatar/" + username, true);
    xhttp.send();          
}


async function cheersCommand(username, targetuser){

  console.log("Cheers: " + username + targetuser);
  let images = [];

    try {
        images.push(await helpers.getTwitchAvatar(username));
    } catch (error) {
        console.error(error);
        throw error;
    }
  
    if(targetuser){
      try {
          images.push(await helpers.getTwitchAvatar(targetuser));
      } catch (error) {
          console.error(error);
          throw error;
      }
        //images.push(helpers.getTwitchAvatar(targetuser));
    } else {
      images.push("https://static-cdn.jtvnw.net/jtv_user_pictures/8e051a26-051f-4abe-bcfa-e13a5d13fad0-profile_image-300x300.png");
    }

    const delayedFunction = helpers.executeWithInterval(function () {
      src_animations.cheers.create(images);
    }, 15000); 

    delayedFunction();

    //posthog.capture('Commands', { property: 'Cheers' })

}

function choonCommand(username){
var xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function () {
    if (this.readyState == 4 && this.status == 200) {
    // get display image for the user
    console.log("got a user image response back: " + xhttp.responseText);
    // console.log(xhttp.responseText);
    
    let avatar = [xhttp.responseText];
    
    //Disabled While Live
    src_animations.choon.createAvatarChoon(avatar);

    }
};

xhttp.open("GET", "https://decapi.me/twitch/avatar/" + username, true);
xhttp.send();
}

// function incomingRaid(data){


//     //RAIDER NAMES DEPRECATED. Switching to just passing the raider details and count  
//     var raiders = data.arguments.raiderNames.split(',');
  
//     console.log(raiders);
  
//     raiders.forEach(async (raider) => {
//       var username = raider;
//       var xhttp = new XMLHttpRequest();
//       console.log("created xmlhttp object");
//       xhttp.onreadystatechange = function () {
//         if (this.readyState == 4 && this.status == 200) {
//           // get display image for the user
//           console.log("got a user image response back");
          
//           avatar = [xhttp.responseText];
//           //Trigger Animation
//           animations.createRaider(avatar);
  
//         }
//       };
//       console.log(username);
//       xhttp.open("GET", "https://decapi.me/twitch/avatar/" + username, true);
//       xhttp.send();  
  
//     });
// }

function lurkCommand(username){
    var xhttp = new XMLHttpRequest();
    console.log("created xmlhttp object");
    xhttp.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        // get display image for the user
        console.log("got the users image back");         
        //Trigger Animation
        src_animations.lurking.create(xhttp.responseText, 3);
      }
    };
    //console.log(username);
    xhttp.open("GET", "https://decapi.me/twitch/avatar/" + username, true);
    xhttp.send();   
}
  
function shoutoutCommand(lowermessage){
            
    // ALLOW - And other word symbols
    let regexp = /\@(.*)/;
    let matches = lowermessage.match(regexp);
    let sousername = matches[1];
    console.log(sousername);
    let xhttp = new XMLHttpRequest();
    console.log("created xmlhttp object");
    xhttp.onreadystatechange = function () {
      if (this.readyState == 4 && this.status == 200) {
        // get display image for the user
        console.log("got a user image response back");
        
        
        let avatar = [xhttp.responseText];
        //console.log(avatar);
        src_animations.rain.emoteRain(avatar, handlers_globalConst.defaultemotes, 50);

      }
    };
    xhttp.open("GET", "https://decapi.me/twitch/avatar/" + sousername, true);
    xhttp.send();           
}

function botChat(message){
  ws.send(JSON.stringify(
    {
      "request": "DoAction",
      "action": {
        "name": "ERTwitchBotChat"
      },
      "args": {
        "message": message,
      },
      "id": "123"
    }
  ));
}

/* harmony default export */ const handlers = ({
  chatMessageHandler,
  actionsHandler,
  emoteMessageHandler,
  firstWordsHander,
  cheersCommand,
  choonCommand,
  lurkCommand,
  shoutoutCommand
});
;// CONCATENATED MODULE: ./src/websocket.js





const { globalVars: websocket_globalVars, globalConst: websocket_globalConst} = config;


let websocket_ws = websocket_globalConst.ws;

function connectws() {
    if ("WebSocket" in window) {
     
      websocket_ws.onclose = function () {
        // "connectws" is the function we defined previously
        setTimeout(connectws, 10000);
      };
  
      //Enable all Events
      websocket_ws.onopen = function () {
        websocket_ws.send(JSON.stringify(
          {
            "request": "Subscribe",
            "events": {
              "Twitch": [
                "ChatMessage", "FirstWord", "HypeTrainStart", "HypeTrainUpdate", "HypeTrainLevelUp", "HypeTrainEnd", "Raid", "Cheer", "Sub", "Resub", "GiftBomb", "GiftSub"
              ],
              "Raw": [
                "Action"
              ],
              "General": [
                "Custom"
              ]
            },
            "id": "123"
          }
        ));
  
        websocket_ws.send(JSON.stringify(
          {
            "request": "GetActions",
            "id": "ActionList"
          }
        ));
      
      };
  
      websocket_ws.onmessage = function (event) {
        // grab message and parse JSON
        const msg = event.data;
        const wsdata = JSON.parse(msg);
  
        console.log(wsdata);
  
        //SetupChecks
        if(typeof wsdata.actions != "undefined" && typeof wsdata.id == "ActionList") {
          let ChatAction = wsdata.actions.filter(function (SBAction) { return SBAction.name == "ERTwitchBotChat" });
          console.log(ChatAction);
          if(ChatAction.length >= 1){
            console.log("True");
            Botchat = true;
          }
        }
  
        //Check if the channel is a gforce sub IN PROGRESS
        if(!websocket_globalConst.channelsub) {
            //   let channelsub = true;
            //console.log("I should only see this once");
        }
  
  
        //Check for Undefined WS Events
        if (typeof wsdata.event == "undefined") {
          console.log("Event undefined");
          return;
        }
        if (typeof wsdata.event.type == "undefined") {
          console.log("Event Type undefined");
          return;
        }

        let eventType = wsdata.event.type;
  
        //Pass to ChatMessageHandler 
        if (eventType == "ChatMessage") {
            handlers.chatMessageHandler(wsdata);
            if(websocket_globalConst.debug){console.log("Passed to ChatMessageHandler");} 
            return;
        }
  
        //Pass to FirstWordsHandler 
        if (eventType == "FirstWord") {
            handlers.firstWordsHander(wsdata);
            return;
        }

        if (eventType == "Sub" || eventType == "Resub" || eventType == "GiftBomb" || eventType == "GiftSub" || eventType == "Cheer"){
            //Cheer uses message.username. Subs use userName
            let userName = wsdata.data.message.username ? wsdata.data.message.username : wsdata.data.userName;

            //Add user to the front of the array
            websocket_globalVars.hypetrainCache.unshift(userName);

            //clear the end of cache if too long
            if(websocket_globalVars.hypetrainCache[3]) {
              websocket_globalVars.hypetrainCache.pop()
            }
        }  
  
        //Hype Train Start - Start the repeating train animation with the train head image and the first cart
        if (eventType == "HypeTrainStart" && (websocket_globalConst.hypetrain || websocket_globalConst.all)) {
            src_animations.hypetrain.hypetrainstart();
            return;
        }
  
        //Hype Train Level Up - Add a cart to the end of the train
        if (eventType == "HypeTrainLevelUp" && (websocket_globalConst.hypetrain || websocket_globalConst.all)) {
            src_animations.hypetrain.hypetrainlevelup();  
            return;
        }
  
  
        //Hype Progression - Add a user to the current train cart
        if (eventType == "HypeTrainUpdate" && (websocket_globalConst.hypetrain || websocket_globalConst.all)) {
          src_animations.hypetrain.hypetrainprogression(wsdata.data.last_contribution.user_id);
          return;
        }
  
        //Hype Train Finish - Remove the Train
        if (eventType == "HypeTrainEnd" && (websocket_globalConst.hypetrain || websocket_globalConst.all)) {
          src_animations.hypetrain.hypetrainfinish();
          return;
        }

        //Incoming Raid
        if (eventType == "Raid") {
          //animations.hypetrain.incomingRaid(wsdata.data.from_broadcaster_user_id, wsdata.data.from_broadcaster_user_name, wsdata.data.viewers);
          return;
        }
  
        //CoinFlipResults
        if (eventType == "Custom") {
          if (wsdata.data.coinFlipResult == "undefined") {
            return
          }
  
          if(wsdata.data.coinFlipResult == "Heads"){
            src_animations.coinflip.createCoins(1, "Heads" );
          }
          if(wsdata.data.coinFlipResult == "Tails"){
            src_animations.coinflip.createCoins(1, "Tails" );
          }
        }
  
        //Actions
        if(eventType == "Action"){
          handlers.actionsHandler(wsdata);
          return
        }
      }
    }
  }



// Function 2
function handleMessage(message) {
// Message handling logic goes here
}

// Export the functions as a single object
/* harmony default export */ const websocket = ({
    connectws,
    handleMessage
});
;// CONCATENATED MODULE: ./src/main.js


//import * as animations from './animations.js';

// import posthog from 'posthog-js';

const { globalVars: main_globalVars, globalConst: main_globalConst} = config;

// Access the functions individually
const { connectws: main_connectws, handleMessage: main_handleMessage } = websocket;

// Use the functions as needed
// connectWebSocket();
// handleMessage(message);

// Initialize the application
function init() {
    gsap.registerPlugin(MotionPathPlugin);
    main_connectws();

    window.animations = src_animations;
}


// posthog.init('phc_2qM9NRYrCyXpC2B50bJTLGvt8Kxvhx40FJTJZpsG19G',
//     {
//         api_host: 'https://us.i.posthog.com',
//         person_profiles: 'identified_only' // or 'always' to create profiles for anonymous users as well
//     }
// )


// Start the application
init();
/******/ })()
;